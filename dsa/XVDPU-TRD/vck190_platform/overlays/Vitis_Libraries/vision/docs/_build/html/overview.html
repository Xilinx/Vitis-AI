


<!DOCTYPE HTML>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta content="Vision, Library, Vitis Vision Library, overview, features, kernel" name="keywords" />
<meta content="Using the Vitis vision library." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />
<meta content="Vision, Library, Vitis Vision Library, design, methodology, OpenCL, OpenCV, libOpenCL" name="keywords" />
<meta content="Describes the methodology to create a kernel, corresponding host code and a suitable makefile to compile an Vitis Vision kernel for any of the supported platforms in Vitis." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />
<meta content="Vision, Library, Vitis Vision Library, cv" name="keywords" />
<meta content="Using the Vitis vision library." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />
<meta content="Vision, Library, Vitis Vision Library, HLS, Getting Started, C-simulation, C-synthesis, co-simulation, cv, Tcl" name="keywords" />
<meta content="Describes the methodology to create a kernel, corresponding host code and a suitable makefile to compile an Vitis Vision kernel for any of the supported platforms in Vitis." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />
<meta content="Vision, Library, Vitis Vision Library, migrate, HLS, Mat, cv, LineBuffer" name="keywords" />
<meta content="Migrating HLS Video Library to Vitis vision." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />
<meta content="Vision, Library, Vitis Vision Library, Iterative Pyramidal, Corner Tracking, cornerUpdate, cornersImgToList," name="keywords" />
<meta content="Design examples Using Vitis Vision library." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />

		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="https://static.cloud.coveo.com/searchui/v2.4382/css/CoveoFullSearch.css"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="description"/>
		<meta name="keywords"/>
		<meta property="og:title" content=""/>
		<meta property="og:description"/>
		<!-- favicon -->
		<link rel="icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<!-- Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css"/>

  
  
  
  

  
      <script type="text/javascript" src="_static/js/jquery.min.js"></script>	
	  <script type="text/javascript" src="_static/js/gtm.js"></script>
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
    <script type="text/javascript" src="_static/js/d3dd8c60ed.js"></script>
    <script type="text/javascript" src="_static/js/common-ui-all.min.js"></script>		
    <script type="text/javascript" src="_static/js/header-footer.min.js"></script>	
    <script type="text/javascript" src="_static/js/jquery-ui.min.js"></script>	
    <script type="text/javascript" src="_static/js/CoveoJsSearch.Lazy.min.js"></script>	
    <script type="text/javascript" src="_static/js/linkid.js"></script>		
    <script type="text/javascript" src="_static/js/Searchbox.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Overview" href="api-reference.html" />
    <link rel="prev" title="Vitis Vision Library" href="index.html" /> 
	</head>
	<body>
		<div class="xilinx-bs3"/>
		<div class="root responsivegrid">
			<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 aem-Grid--large--16 aem-Grid--xlarge--16 aem-Grid--xxlarge--16 aem-Grid--xxxlarge--16 ">
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn aem-GridColumn--default--12">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="header parbase aem-GridColumn aem-GridColumn--default--12">
								<noindex>
									<header data-component="header">
										<nav class="navbar navbar-default aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid main-nav">
													<div class="row">
														<div class="col-xs-12">
															<div class="logo-column">
																<div class="logo">
																	<a href="https://www.xilinx.com/">
																	<img src="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/imgs/header/xilinx-header-logo.svg" title="Xilinx Inc"/>
																	</a>
																</div>
															</div>
															<div class="navbar-column">
																<div class="navbar navbar-collapse collapse" id="xilinx-main-menu">
																	<div class="mobile-search-container">
																		<div id="headerSearchBox" class="headerSearch"
																			data-component="header-search" 
																			data-redirect-if-empty="false"
																			data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																			data-coveo-organization-id="xilinxcomprode2rjoqok">
																			<div class='coveo-search-section'>
																				<div class="CoveoAnalytics" data-search-hub="Site"></div>
																				<ul class="dropdown-menu options">
																					<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																						<a href="#">
																						All</a>
																					</li>
																					<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com//products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Silicon Devices</a>
																					</li>
																					<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com//products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Boards and Kits</a>
																					</li>
																					<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com//products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Intellectual Property</a>
																					</li>
																					<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																						<a href="#">
																						Support</a>
																						<ul>
																							<li data-label="Documentation" data-action-link="https://www.xilinx.com//support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																								<a href="#">
																								Documentation</a>
																							</li>
																							<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com//support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																								<a href="#">
																								Knowledge Base</a>
																							</li>
																							<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																								<a href="#">
																								Community Forums</a>
																							</li>
																						</ul>
																					</li>
																					<li data-label="Partners" data-action-link="https://www.xilinx.com//alliance/member-keyword-search.html" data-search-hub="Partner">
																						<a href="#">
																						Partners</a>
																					</li>
																					<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																						<a href="#">
																						Videos</a>
																					</li>
																					<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																						<a href="#">
																						Press</a>
																					</li>
																				</ul>
																				<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																				<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																			</div>
																		</div>
																	</div>
																	<ul class="nav navbar-nav nav-justified">
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/applications.html">
																			Applications</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/products/silicon-devices.html">
																			Products</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://developer.xilinx.com/">
																			Developers</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/support.html">
																			Support</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/about/company-overview.html">
																			About</a> 
																		</li>
																	</ul>
																</div>
															</div>
															<script type="text/javascript" src="_static/js/gtm.js"></script>
															<!--<div class="mini-nav">
																<button type="button" data-function="xilinx-mobile-menu" id="nav-toggle" class="navbar-toggle collapsed visible-xs-block" aria-expanded="false">
																<span></span>
																<span></span>
																<span></span>
																<span></span>
																</button>
																<ul class="list-inline">
																	<li class="dropdown user-menu">
																		<button data-toggle="dropdown">
																		<span class="sr-only">Account</span>
																		<span class="fas fa-user"></span>
																		</button>
																		<ul class="dropdown-menu">
																			<li>
																				<a href="https://www.xilinx.com/myprofile/subscriptions.html">
																				My Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/registration/create-account.html">
																				Create Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/bin/protected/en/signout">
																				Sign Out</a>
																			</li>
																		</ul>
																	</li>
																	<li class="hidden-xs">
																		<button data-function="search-toggle">
																		<span class="sr-only">Search</span>
																		<span class="far fa-search"></span>
																		</button>
																	</li>
																</ul>
															</div>
															-->
															<div class="search-container">
																<div id="headerSearchBox" class="headerSearch"
																	data-component="header-search" 
																	data-redirect-if-empty="false"
																	data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																	data-coveo-organization-id="xilinxcomprode2rjoqok">
																	<div class='coveo-search-section'>
																		<div class="CoveoAnalytics" data-search-hub="Site"></div>
																		<ul class="dropdown-menu options">
																			<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																				<a href="#">
																				All</a>
																			</li>
																			<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com/products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Silicon Devices</a>
																			</li>
																			<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com/products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Boards and Kits</a>
																			</li>
																			<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com/products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Intellectual Property</a>
																			</li>
																			<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																				<a href="#">
																				Support</a>
																				<ul>
																					<li data-label="Documentation" data-action-link="https://www.xilinx.com/support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																						<a href="#">
																						Documentation</a>
																					</li>
																					<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com/support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																						<a href="#">
																						Knowledge Base</a>
																					</li>
																					<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																						<a href="#">
																						Community Forums</a>
																					</li>
																				</ul>
																			</li>
																			<li data-label="Partners" data-action-link="https://www.xilinx.com/alliance/member-keyword-search.html" data-search-hub="Partner">
																				<a href="#">
																				Partners</a>
																			</li>
																			<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																				<a href="#">
																				Videos</a>
																			</li>
																			<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																				<a href="#">
																				Press</a>
																			</li>
																		</ul>
																		<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																		<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																	</div>
																</div>
																<button data-function="search-toggle">
																<span class="sr-only">Search</span>
																<span class="far fa-times"></span>
																</button>
															</div>
														</div>
													</div>
												</div>
											</div>
										</nav>
									</header>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="parsys aem-GridColumn--xxxlarge--none aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
						<div class="container-fluid">
							<div class="row">
							<div class="col-xs-12">
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Vitis Vision Library
          

          
          </a>

          
            
            
              <div class="version">
                2020.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Vitis Vision Library User Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-features">Basic Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vitis-vision-kernel-on-vitis">Vitis Vision Kernel on Vitis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vitis-vision-library-contents">Vitis Vision Library Contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#getting-started-with-vitis-vision">Getting Started with Vitis Vision</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vitis-design-methodology">Vitis Design Methodology</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#host-code-with-opencl">Host Code with OpenCL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wrappers-around-hls-kernel-s">Wrappers around HLS Kernel(s)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stream-based-kernels">Stream Based Kernels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array2xfmat">Array2xfMat</a></li>
<li class="toctree-l4"><a class="reference internal" href="#xfmat2array">xfMat2Array</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interface-pointer-widths">Interface pointer widths</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-to-kernel-streaming">Kernel-to-Kernel streaming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axistrm2xfmat">axiStrm2xfMat</a></li>
<li class="toctree-l4"><a class="reference internal" href="#xfmat2axistrm">xfMat2axiStrm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-mapped-kernels">Memory Mapped Kernels</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#makefile">Makefile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#design-example-using-library-on-vitis">Design example Using Library on Vitis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#host-code">Host code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#top-level-kernel">Top level kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#evaluating-the-functionality">Evaluating the Functionality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#software-emulation">Software Emulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hardware-emulation">Hardware Emulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-on-the-hardware">Testing on the Hardware</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-vitis-vision-library">Using the Vitis vision Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#changing-the-hardware-kernel-configuration">Changing the Hardware Kernel Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-vitis-vision-library-functions-on-hardware">Using the Vitis vision Library Functions on Hardware</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#getting-started-with-hls">Getting Started with HLS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#hls-standalone-mode">HLS Standalone Mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tcl-script-mode">Tcl Script Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gui-mode">GUI Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints-for-co-simulation">Constraints for Co-simulation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#axi-video-interface-functions">AXI Video Interface Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#axivideo2xfmat">AXIvideo2xfMat</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xfmat2axivideo">xfMat2AXIvideo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvmat2axivideoxf">cvMat2AXIvideoxf</a></li>
<li class="toctree-l3"><a class="reference internal" href="#axivideo2cvmatxf">AXIvideo2cvMatxf</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#migrating-hls-video-library-to-vitis-vision">Migrating HLS Video Library to Vitis vision</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#infrastructure-functions-and-classes">Infrastructure Functions and Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#funtions">Funtions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xf-cv-window">xf::cv::window</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-definition">Class definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameter-descriptions">Parameter Descriptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#member-function-description">Member Function Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#template-parameter-description">Template Parameter Description</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#xf-cv-linebuffer">xf::cv::LineBuffer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-definition-1">Class definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameter-descriptions-1">Parameter Descriptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#member-functions-description">Member Functions Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#template-parameter-description-1">Template Parameter Description</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#video-processing-functions">Video Processing Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#design-examples-using-vitis-vision-library">Design Examples Using Vitis Vision Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#interative-pyramidal">Iterative Pyramidal Dense Optical Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#corner-tracking">Corner Tracking Using Optical Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cornerupdate">cornerUpdate()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cornersimgtolist">cornersImgToList()</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#image-processing">Image Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id9">Color Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#difference-gaussian-filter">Difference of Gaussian Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stereo-vision">Stereo Vision Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#x-mlpipeline">X + ML Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#letter-box">Letterbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="#isp">Image Sensor Processing pipeline</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#xf-cv-mat-image-container-class">xf::cv::Mat Image Container Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#vitis-vision-library-functions">Vitis Vision Library Functions</a></li>
</ul>

            
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/overview.rst.txt"
						rel="nofollow">Show Source</a></li>						
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vitis Vision Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview">
<span id="id1"></span><h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<p>The Vitis vision library has been designed to work in the Vitis development environment, and provides a software
interface for computer vision functions accelerated on an FPGA device.
Vitis vision library functions are mostly similar in functionality to their
OpenCV equivalent. Any deviations, if present, are documented.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more information on the Vitis vision library prerequisites, see <a class="reference internal" href="#prerequisites">Prerequisites</a>.</p>
</div>
<p>To familiarize yourself with the steps required to use the Vitis vision library
functions, see the <a class="reference external" href="using-the-vitis-vision-library.html">Using the Vitis vision
Library</a>.</p>
<div class="section" id="basic-features">
<span id="id2"></span><h2>Basic Features<a class="headerlink" href="#basic-features" title="Permalink to this headline">¶</a></h2>
<p>All Vitis vision library functions follow a common format. The following
properties hold true for all the functions.</p>
<ul class="simple">
<li>All the functions are designed as templates and all arguments that
are images, must be provided as <code class="docutils literal notranslate"><span class="pre">xf::cv::Mat</span></code>.</li>
<li>All functions are defined in the <code class="docutils literal notranslate"><span class="pre">xf::cv</span></code> namespace.</li>
<li>Some of the major template arguments are:<ul>
<li>Maximum size of the image to be processed</li>
<li>Datatype defining the properties of each pixel</li>
<li>Number of pixels to be processed per clock cycle</li>
<li>Other compile-time arguments relevent to the functionality.</li>
</ul>
</li>
</ul>
<p>The Vitis vision library contains enumerated datatypes which enables you to
configure <code class="docutils literal notranslate"><span class="pre">xf::cv::Mat</span></code>. For more details on <code class="docutils literal notranslate"><span class="pre">xf::cv::Mat</span></code>, see the <a class="reference external" href="api-reference.html">xf::cv::Mat
Image Container Class</a>.</p>
</div>
<div class="section" id="vitis-vision-kernel-on-vitis">
<span id="xfopencv-kernel"></span><h2>Vitis Vision Kernel on Vitis<a class="headerlink" href="#vitis-vision-kernel-on-vitis" title="Permalink to this headline">¶</a></h2>
<p>The Vitis vision library is designed to be used with the Vitis development
environment.</p>
<p>The OpenCL host code is written in the testbench file, whereas the calls to Vitis
Vision functions are done from the accel file.
The image containers for Vitis vision library functions are <code class="docutils literal notranslate"><span class="pre">xf::cv::Mat</span></code>
objects. For more information, see the <a class="reference external" href="api-reference.html">xf::cv::Mat Image Container
Class</a>.</p>
</div>
<div class="section" id="vitis-vision-library-contents">
<span id="xfopencv-lib-contents"></span><h2>Vitis Vision Library Contents<a class="headerlink" href="#vitis-vision-library-contents" title="Permalink to this headline">¶</a></h2>
<p>The following table lists the contents of the Vitis vision library.</p>
<table border="1" class="docutils" id="id16">
<caption><span class="caption-text">Vitis Vision Library Contents</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Folder</th>
<th class="head">Details</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>L1/examples</td>
<td>Contains the sample testbench code
to facilitate running unit tests
on Vitis/Vivado HLS. The examples/
has folders with algorithm names.
Each algorithm folder contains
testbench, accel, config, Makefile
, Json file and a ‘build’ folder.</td>
</tr>
<tr class="row-odd"><td>L1/include/common</td>
<td>Contains the common library
infrastructure headers, such as
types specific to the library.</td>
</tr>
<tr class="row-even"><td>L1/include/core</td>
<td>Contains the core library
functionality headers, such as
the <code class="docutils literal notranslate"><span class="pre">math</span></code> functions.</td>
</tr>
<tr class="row-odd"><td>L1/include/features</td>
<td>Contains the feature extraction
kernel function definitions. For
example, <code class="docutils literal notranslate"><span class="pre">Harris</span></code>.</td>
</tr>
<tr class="row-even"><td>L1/include/imgproc</td>
<td>Contains all the kernel function
definitions related to image proce
ssing definitions.</td>
</tr>
<tr class="row-odd"><td>L1/include/video</td>
<td>Contains all the kernel function
definitions, related to video proc
essing functions.eg:Optical flow</td>
</tr>
<tr class="row-even"><td>L1/include/dnn</td>
<td>Contains all the kernel function
definitions, related to deep lea
rning preprocessing.</td>
</tr>
<tr class="row-odd"><td>L1/tests</td>
<td>Contains all test folders to run
simulations, synthesis and export
RTL.The tests folder contains the
folders with algorithm names.Each
algorithm folder further contains
configuration folders, that has
makefile and tcl files to run
tests.</td>
</tr>
<tr class="row-even"><td>L1/examples/build</td>
<td>Contains xf_config_params.h file,
which has configurable macros and
varibales related to the particula
r example.</td>
</tr>
<tr class="row-odd"><td>L2/examples</td>
<td>Contains the sample testbench code
to facilitate running unit tests
on Vitis. The examples/ contains
the folders with algorithm names.
Each algorithm folder contains
testbench, accel, config, Makefile
, Json file and a ‘build’ folder.</td>
</tr>
<tr class="row-even"><td>L2/tests</td>
<td>Contains all test folders to run
software, hardware emulations
and hardware build. The tests cont
ains folders with algorithm names.
Each algorithm folder further cont
ains configuration folders, that
has makefile and tcl files to run
tests.</td>
</tr>
<tr class="row-odd"><td>L2/examples/build</td>
<td>Contains xf_config_params.h file,
which has configurable macros and
varibales related to the particula
r example.</td>
</tr>
<tr class="row-even"><td>L3/examples</td>
<td>Contains the sample testbench code
to build pipeline functions
on Vitis. The examples/ contains
the folders with algorithm names.
Each algorithm folder contains
testbench, accel, config, Makefile
, Json file and a ‘build’ folder.</td>
</tr>
<tr class="row-odd"><td>L3/tests</td>
<td>Contains all test folders to run
software, hardware emulations
and hardware build.The tests cont
ains folders with algorithm names.
Each algorithm name folder contai
ns the configuration folders,
inside configuration folders
makefile is present to run tests.</td>
</tr>
<tr class="row-even"><td>L3/examples/build</td>
<td>Contains xf_config_params.h file,
which has configurable macros and
varibales related to the particula
r example.</td>
</tr>
<tr class="row-odd"><td>L3/benchmarks</td>
<td>Contains benchmark examples to
compare the software
implementation versus FPGA
implementation using Vitis vision
library.</td>
</tr>
<tr class="row-even"><td>ext</td>
<td>Contains the utility functions
related to opencl hostcode.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="getting-started-with-vitis-vision">
<h1>Getting Started with Vitis Vision<a class="headerlink" href="#getting-started-with-vitis-vision" title="Permalink to this headline">¶</a></h1>
<p>Describes the methodology to create a kernel, corresponding host code and a suitable
makefile to compile an Vitis Vision kernel for any of the supported
platforms in Vitis. The subsequent section also explains the
methodology to verify the kernel in various emulation modes and on the
hardware.</p>
<div class="section" id="prerequisites">
<span id="id3"></span><h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Valid installation of Vitis™ 2020.1 or later version and the
corresponding licenses.</li>
<li>Install the Vitis Vision libraries, if you intend to use libraries
compiled differently than what is provided in Vitis.</li>
<li>Install the card for which the platform is supported in Vitis 2020.1 or
later versions.</li>
<li>If targeting an embedded platform, set up the evaluation board.</li>
<li>Xilinx® Runtime (XRT) must be installed. XRT provides software
interface to Xilinx FPGAs.</li>
<li>Install/compile OpenCV libraries(with compatible libjpeg.so).
Appropriate version (X86/aarch32/aarch64) of compiler must be used based
on the available processor on the target board.</li>
<li>libOpenCL.so must be installed if not present along with the
platform.</li>
</ol>
</div>
<div class="section" id="vitis-design-methodology">
<h2>Vitis Design Methodology<a class="headerlink" href="#vitis-design-methodology" title="Permalink to this headline">¶</a></h2>
<p>There are three critical components in making a kernel work on a
platform using Vitis™:</p>
<ol class="arabic simple">
<li>Host code with OpenCL constructs</li>
<li>Wrappers around HLS Kernel(s)</li>
<li>Makefile to compile the kernel for emulation or running on hardware.</li>
</ol>
<div class="section" id="host-code-with-opencl">
<h3>Host Code with OpenCL<a class="headerlink" href="#host-code-with-opencl" title="Permalink to this headline">¶</a></h3>
<p>Host code is compiled for the host machine that runs on the host and
provides the data and control signals to the attached hardware with the
FPGA. The host code is written using OpenCL constructs and provides
capabilities for setting up, and running a kernel on the FPGA. The
following functions are executed using the host code:</p>
<ol class="arabic simple">
<li>Loading the kernel binary on the FPGA – xcl::import_binary_file()
loads the bitstream and programs the FPGA to enable required
processing of data.</li>
<li>Setting up memory buffers for data transfer – Data needs to be sent
and read from the DDR memory on the hardware. cl::Buffers are created
to allocate required memory for transferring data to and from the
hardware.</li>
<li>Transfer data to and from the hardware –enqueueWriteBuffer() and
enqueueReadBuffer() are used to transfer the data to and from the
hardware at the required time.</li>
<li>Execute kernel on the FPGA – There are functions to execute kernels
on the FPGA. There can be single kernel execution or multiple kernel
execution that could be asynchronous or synchronous with each other.
Commonly used command is enqueueTask().</li>
<li>Profiling the performance of kernel execution – The host code in
OpenCL also enables measurement of the execution time of a kernel on
the FPGA. The function used in our examples for profiling is
getProfilingInfo().</li>
</ol>
</div>
<div class="section" id="wrappers-around-hls-kernel-s">
<h3>Wrappers around HLS Kernel(s)<a class="headerlink" href="#wrappers-around-hls-kernel-s" title="Permalink to this headline">¶</a></h3>
<p>All Vitis Vision kernels are provided with C++ function templates (located
at &lt;Github repo&gt;/include) with image containers as objects of xf::cv::Mat
class. In addition, these kernels will work either in stream based
(where complete image is read continuously) or memory mapped (where
image data access is in blocks).</p>
<p>Vitis flow (OpenCL) requires kernel interfaces to be memory pointers
with width in power(s) of 2. So glue logic is required for converting
memory pointers to xf::cv::Mat class data type and vice-versa when
interacting with Vitis Vision kernel(s). Wrapper(s) are build over the
kernel(s) with this glue logic. Below examples will provide a
methodology to handle different kernel (Vitis Vision kernels located at
&lt;Github repo&gt;/include) types (stream and memory mapped).</p>
<div class="section" id="stream-based-kernels">
<h4>Stream Based Kernels<a class="headerlink" href="#stream-based-kernels" title="Permalink to this headline">¶</a></h4>
<p>To facilitate the conversion of pointer to xf::Mat and vice versa, two
adapter functions are included as part of Vitis Vision xf::cv::Array2xfMat() and
xf::cv::xfMat2Array(). It is necessary for the xf::Mat objects to be invoked
as streams using HLS pragma with a minimum depth of 2. This results in a
top-level (or wrapper) function for the kernel as shown below:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C”
{
void func_top (ap_uint *gmem_in, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;…&gt; in_mat(…), out_mat(…);
#pragma HLS dataflow
xf::cv::Array2xfMat&lt;…&gt; (gmem_in, in_mat);
xf::cv::Vitis Vision-func&lt;…&gt; (in_mat, out_mat…);
xf::cv::xfMat2Array&lt;…&gt; (gmem_out, out_mat);
}
}
</pre></div>
</div>
<p>The above illustration assumes that the data in xf::cv::Mat is being
streamed in and streamed out. You can also create a pipeline with
multiple functions in pipeline instead of just one Vitis Vision function.</p>
<p>For the stream based kernels with different inputs of different sizes,
multiple instances of the adapter functions are necessary. For this,</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C” {
void func_top (ap_uint *gmem_in1, ap_uint *gmem_in2, ap_uint *gmem_in3, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;...,HEIGHT,WIDTH,…&gt; in_mat1(…), out_mat(…);
xf::cv::Mat&lt;...,HEIGHT/4,WIDTH,…&gt;  in_mat2(…), in_mat3(…);
#pragma HLS dataflow
xf::cv::accel_utils obj_a, obj_b;
obj_a.Array2xfMat&lt;…,HEIGHT,WIDTH,…&gt; (gmem_in1, in_mat1);
obj_b.Array2xfMat&lt;…,HEIGHT/4,WIDTH,…&gt; (gmem_in2, in_mat2);
obj_b.Array2xfMat&lt;…,HEIGHT/4,WIDTH,…&gt; (gmem_in3, in_mat3);
xf::cv::Vitis-Vision-func(in_mat1, in_mat2, int_mat3, out_mat…);
xf::cv::xfMat2Array&lt;…&gt; (gmem_out, out_mat);
}
}
</pre></div>
</div>
<p>For the stream based implementations, the data must be fetched from the
input AXI and must be pushed to xfMat as required by the xfcv kernels
for that particular configuration. Likewise, the same operations must be
performed for the output of the xfcv kernel. To perform this, two
utility functions are provided, xf::cv::Array2xfMat() and xf::cv::xfMat2Array().</p>
</div>
<div class="section" id="array2xfmat">
<h4>Array2xfMat<a class="headerlink" href="#array2xfmat" title="Permalink to this headline">¶</a></h4>
<p>This function converts the input array to xf::cv::Mat. The Vitis Vision kernel
would require the input to be of type, xf::cv::Mat. This function would read
from the array pointer and write into xf::cv::Mat based on the particular
configuration (bit-depth, channels, pixel-parallelism) the xf::cv::Mat was
created.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">Array2xfMat</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span> <span class="n">PTR_WIDTH</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">srcPtr</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">dstMat</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id17">
<caption><span class="caption-text">Table. Array2xfMat Parmater Description</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the input pointer.
The value must be power 2,
starting from 8 to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>srcPtr</td>
<td>Input pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>dstMat</td>
<td>Output image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="xfmat2array">
<h4>xfMat2Array<a class="headerlink" href="#xfmat2array" title="Permalink to this headline">¶</a></h4>
<p>This function converts the input xf::cv::Mat to output array. The output of
the xf::kernel function will be xf::cv::Mat, and it will require to convert
that to output pointer.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">xfMat2Array</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">srcMat</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span> <span class="n">PTR_WIDTH</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">dstPtr</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id18">
<caption><span class="caption-text">Table . xfMat2Array Parameter Description</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the output pointer.
The value must be power 2, from 8
to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1,
XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in
parallel. Example XF_NPPC1,
XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>dstPtr</td>
<td>Output pointer. Type of the
pointer based on the PTR_WIDTH.</td>
</tr>
<tr class="row-even"><td>srcMat</td>
<td>Input image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="interface-pointer-widths">
<h4>Interface pointer widths<a class="headerlink" href="#interface-pointer-widths" title="Permalink to this headline">¶</a></h4>
<p>Minimum pointer widths for different configurations is shown in the
following table:</p>
<p>types</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MAT type</th>
<th class="head">Parallelism</th>
<th class="head">Min PTR_WIDTH</th>
<th class="head">Max PTR_WIDTH</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_8UC1</td>
<td>XF_NPPC1</td>
<td>8</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_16UC1</td>
<td>XF_NPPC1</td>
<td>16</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC1</td>
<td>XF_NPPC8</td>
<td>64</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 16UC1</td>
<td>XF_NPPC8</td>
<td>128</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_ 8UC3</td>
<td>XF_NPPC1</td>
<td>32</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_ 8UC3</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-even"><td>XF_8UC4</td>
<td>XF_NPPC8</td>
<td>256</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>XF_8UC3</td>
<td>XF_NPPC16</td>
<td>512</td>
<td>512</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="kernel-to-kernel-streaming">
<h4>Kernel-to-Kernel streaming<a class="headerlink" href="#kernel-to-kernel-streaming" title="Permalink to this headline">¶</a></h4>
<p>There are two utility functions available in Vitis Vision, axiStrm2xfMat and xfMat2axiStrm to support streaming
of data between two kernels. For more details on kernel-to-kernel streaming, refer to the “Streaming Data Transfers Between the
Kernels” section of UG1277 document.</p>
</div>
<div class="section" id="axistrm2xfmat">
<h4>axiStrm2xfMat<a class="headerlink" href="#axistrm2xfmat" title="Permalink to this headline">¶</a></h4>
<p>axiStrm2xfMat is used by consumer kernel to support streaming data transfer between two kernels.
Consumer kernel receives data from producer kernel through kernel streaming interface which is defined by hls:stream
with the ap_axiu&lt; PTR_WIDTH, 0, 0, 0&gt; data type. axiStrm2xfMat would read from AXI stream and write into xf::cv:Mat based
on particular configuration (bit-depth, channels, pixel-parallelism) the xf::cv:Mat was created.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">axiStrm2xfMat</span><span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">srcPtr</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">dstMat</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id19">
<caption><span class="caption-text">Table . Parameter description of axiStrm2xfMat function</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the input pointer. The value must be power 2, starting from 8 to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1, XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in parallel. Example XF_NPPC1, XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>srcPtr</td>
<td>Input image of type hls::stream&lt;ap_axiu&lt;PTR_WIDTH, 0, 0, 0&gt; &gt;</td>
</tr>
<tr class="row-even"><td>dstMat</td>
<td>Output image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="xfmat2axistrm">
<h4>xfMat2axiStrm<a class="headerlink" href="#xfmat2axistrm" title="Permalink to this headline">¶</a></h4>
<p>xfMat2axiStrm is used by producer kernel to support streaming data transfer between two kernels.
This function converts the input xf:cv::Mat to AXI stream based on particular configuration (bit-depth, channels, pixel-parallelism).</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">MAT_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">xfMat2axiStrm</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">MAT_T</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">srcMat</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">dstPtr</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils" id="id20">
<caption><span class="caption-text">Table . Parameter description of xfMat2axiStrm function</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTR_WIDTH</td>
<td>Data width of the input pointer. The value must be power 2, starting from 8 to 512.</td>
</tr>
<tr class="row-odd"><td>MAT_T</td>
<td>Input Mat type. Example XF_8UC1, XF_16UC1, XF_8UC3 and XF_8UC4</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of image</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels computed in parallel. Example XF_NPPC1, XF_NPPC8</td>
</tr>
<tr class="row-odd"><td>srcPtr</td>
<td>Input image of type hls::stream&lt;ap_axiu&lt;PTR_WIDTH, 0, 0, 0&gt; &gt;</td>
</tr>
<tr class="row-even"><td>dstMat</td>
<td>Output image of type xf::cv::Mat</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="memory-mapped-kernels">
<h4>Memory Mapped Kernels<a class="headerlink" href="#memory-mapped-kernels" title="Permalink to this headline">¶</a></h4>
<p>In the memory map based kernels such as crop, Mean-shift tracking and
bounding box, the input read will be for particular block of memory
based on the requirement for the algorithm. The streaming interfaces
will require the image to be read in raster scan manner, which is not
the case for the memory mapped kernels. The methodology to handle this
case is as follows:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern “C”
{
void func_top (ap_uint *gmem_in, ap_uint *gmem_out, ...) {
xf::cv::Mat&lt;…&gt; in_mat(…,gmem_in), out_mat(…,gmem_out);
xf::cv::kernel&lt;…&gt; (in_mat, out_mat…);
}
}
</pre></div>
</div>
<p>The gmem pointers must be mapped to the xf::cv::Mat objects during the
object creation, and then the memory mapped kernels are called with
these mats at the interface. It is necessary that the pointer size must
be same as the size required for the xf::Vitis-Vision-func, unlike the
streaming method where any higher size of the pointers (till 512-bits)
are allowed.</p>
</div>
</div>
<div class="section" id="makefile">
<h3>Makefile<a class="headerlink" href="#makefile" title="Permalink to this headline">¶</a></h3>
<p>Examples for makefile are provided in the examples and tests section of GitHub.</p>
</div>
<div class="section" id="design-example-using-library-on-vitis">
<h3>Design example Using Library on Vitis<a class="headerlink" href="#design-example-using-library-on-vitis" title="Permalink to this headline">¶</a></h3>
<p>Following is a multi-kernel example, where different kernel runs
sequentially in a pipeline to form an application. This example performs
Canny edge detection, where two kernels are involved, Canny and edge
tracing. Canny function will take gray-scale image as input and provided
the edge information in 3 states (weak edge (1), strong edge (3), and
background (0)), which is being fed into edge tracing, which filters out
the weak edges. The prior works in a streaming based implementation and
the later in a memory mapped manner.</p>
<div class="section" id="host-code">
<h4>Host code<a class="headerlink" href="#host-code" title="Permalink to this headline">¶</a></h4>
<p>The following is the Host code for the canny edge detection example. The
host code sets up the OpenCL platform with the FPGA of processing
required data. In the case of Vitis Vision example, the data is an image.
Reading and writing of images are enabled using called to functions from
Vitis Vision.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">setting</span> <span class="n">up</span> <span class="n">device</span> <span class="ow">and</span> <span class="n">platform</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">Device</span><span class="o">&gt;</span> <span class="n">devices</span> <span class="o">=</span> <span class="n">xcl</span><span class="p">::</span><span class="n">get_xil_devices</span><span class="p">();</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Device</span> <span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Context</span> <span class="n">context</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">CommandQueue</span> <span class="n">q</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span><span class="n">CL_QUEUE_PROFILING_ENABLE</span><span class="p">);</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">device_name</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">CL_DEVICE_NAME</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Kernel</span> <span class="mi">1</span><span class="p">:</span> <span class="n">Canny</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">binaryFile</span><span class="o">=</span><span class="n">xcl</span><span class="p">::</span><span class="n">find_binary_file</span><span class="p">(</span><span class="n">device_name</span><span class="p">,</span><span class="s2">&quot;krnl_canny&quot;</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Program</span><span class="p">::</span><span class="n">Binaries</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">xcl</span><span class="p">::</span><span class="n">import_binary_file</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">);</span>
    <span class="n">devices</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Program</span> <span class="n">program</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="n">bins</span><span class="p">);</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">krnl</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="s2">&quot;canny_accel&quot;</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">creating</span> <span class="n">necessary</span> <span class="n">cl</span> <span class="n">buffers</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">and</span> <span class="n">output</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageToDevice</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_READ_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">));</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageFromDevice</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>


    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">arguments</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">imageToDevice</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">imageFromDevice</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">low_threshold</span><span class="p">);</span>
    <span class="n">krnl</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">high_threshold</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">write</span> <span class="n">the</span> <span class="nb">input</span> <span class="n">image</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">host</span> <span class="n">to</span> <span class="n">device</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="p">)),</span><span class="n">img_gray</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">start</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">krnl</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>
    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">profiling</span>
    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
    <span class="n">diff_prof</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">diff_prof</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s2">&quot;ms&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Kernel</span> <span class="mi">2</span><span class="p">:</span> <span class="n">edge</span> <span class="n">tracing</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">krnl2</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="s2">&quot;edgetracing_accel&quot;</span><span class="p">);</span>

    <span class="n">cl</span><span class="p">::</span><span class="n">Buffer</span> <span class="n">imageFromDeviceedge</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">));</span>

    <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">arguments</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">imageFromDevice</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">imageFromDeviceedge</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">krnl2</span><span class="o">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">startedge</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">endedge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof_edge</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp_edge</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">krnl2</span><span class="p">,</span><span class="n">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">event_sp_edge</span><span class="p">);</span>
    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">event_sp_edge</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">profiling</span>
    <span class="n">event_sp_edge</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span><span class="o">&amp;</span><span class="n">startedge</span><span class="p">);</span>
    <span class="n">event_sp_edge</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span><span class="o">&amp;</span><span class="n">endedge</span><span class="p">);</span>
    <span class="n">diff_prof_edge</span> <span class="o">=</span> <span class="n">endedge</span><span class="o">-</span><span class="n">startedge</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">diff_prof_edge</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s2">&quot;ms&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>


    <span class="o">//</span><span class="n">Copying</span> <span class="n">Device</span> <span class="n">result</span> <span class="n">data</span> <span class="n">to</span> <span class="n">Host</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDeviceedge</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,(</span><span class="n">height</span><span class="o">*</span><span class="n">width</span><span class="p">),</span><span class="n">out_img_edge</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="top-level-kernel">
<h4>Top level kernel<a class="headerlink" href="#top-level-kernel" title="Permalink to this headline">¶</a></h4>
<p>Below is the top-level/wrapper function with all necessary glue logic.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">streaming</span> <span class="n">based</span> <span class="n">kernel</span>
<span class="c1">#include &quot;xf_canny_config.h&quot;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="n">void</span> <span class="n">canny_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">,</span><span class="nb">int</span> <span class="n">low_threshold</span><span class="p">,</span><span class="nb">int</span> <span class="n">high_threshold</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_inp  bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_out  bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=low_threshold     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=high_threshold     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">INTYPE</span><span class="o">&gt;</span> <span class="n">in_mat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="o">&gt;</span> <span class="n">dst_mat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">INTYPE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_inp</span><span class="p">,</span><span class="n">in_mat</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Canny</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span><span class="n">NORM_TYPE</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span><span class="n">INTYPE</span><span class="p">,</span><span class="n">XF_NPPC32</span><span class="p">,</span><span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">in_mat</span><span class="p">,</span><span class="n">dst_mat</span><span class="p">,</span><span class="n">low_threshold</span><span class="p">,</span><span class="n">high_threshold</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">XF_NPPC32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dst_mat</span><span class="p">,</span><span class="n">img_out</span><span class="p">);</span>


<span class="p">}</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">memory</span> <span class="n">mapped</span> <span class="n">kernel</span>
<span class="c1">#include &quot;xf_canny_config.h&quot;</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="n">void</span> <span class="n">edgetracing_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_inp  bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=img_out  bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>


    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="o">&gt;</span> <span class="n">_dst1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="n">img_inp</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC8</span><span class="o">&gt;</span> <span class="n">_dst2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="n">img_out</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">EdgeTracing</span><span class="o">&lt;</span><span class="n">XF_2UC1</span><span class="p">,</span><span class="n">XF_8UC1</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC32</span><span class="p">,</span><span class="n">XF_NPPC8</span><span class="p">,</span><span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_dst1</span><span class="p">,</span><span class="n">_dst2</span><span class="p">);</span>

<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="evaluating-the-functionality">
<h2>Evaluating the Functionality<a class="headerlink" href="#evaluating-the-functionality" title="Permalink to this headline">¶</a></h2>
<p>You can build the kernels and test the functionality through software
emulation, hardware emulation, and running directly on a supported
hardware with the FPGA. For PCIe based platforms, use the following
commands to setup the environment:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd &lt;path to the folder where makefile is present&gt;
$ source &lt;path to the Vitis installation folder&gt;/Vitis/&lt;version number&gt;/settings64.sh
$ source &lt;path to Xilinx_xrt&gt;/setup.sh
$ export DEVICE=&lt;path-to-platform-directory&gt;/&lt;platform&gt;.xpfm
</pre></div>
</div>
<div class="section" id="software-emulation">
<h3>Software Emulation<a class="headerlink" href="#software-emulation" title="Permalink to this headline">¶</a></h3>
<p>Software emulation is equivalent to running a C-simulation of the
kernel. The time for compilation is minimal, and is therefore
recommended to be the first step in testing the kernel. Following are
the steps to build and run for the software emulation:</p>
<p><em>For PCIe devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ make host xclbin TARGET=sw_emu

$ make run TARGET=sw_emu
</pre></div>
</div>
<p><em>For embedded devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ export SYSROOT=&lt; path-to-platform-sysroot &gt;

$ make host xclbin TARGET=sw_emu BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;

$ make run TARGET=sw_emu BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;
</pre></div>
</div>
</div>
<div class="section" id="hardware-emulation">
<h3>Hardware Emulation<a class="headerlink" href="#hardware-emulation" title="Permalink to this headline">¶</a></h3>
<p>Hardware emulation runs the test on the generated RTL after synthesis of
the C/C++ code. The simulation, since being done on RTL requires longer
to complete when compared to software emulation. Following are the steps
to build and run for the hardware emulation:</p>
<p><em>For PCIe devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ make host xclbin TARGET=hw_emu

$ make run TARGET=hw_emu
</pre></div>
</div>
<p><em>For embedded devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ export SYSROOT=&lt; path-to-platform-sysroot &gt;

$ make host xclbin TARGET=hw_emu BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;

$ make run TARGET=hw_emu BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;
</pre></div>
</div>
</div>
<div class="section" id="testing-on-the-hardware">
<h3>Testing on the Hardware<a class="headerlink" href="#testing-on-the-hardware" title="Permalink to this headline">¶</a></h3>
<p>To test on the hardware, the kernel must be compiled into a bitstream
(building for hardware). This would consume some time since the C/C++ code must be converted to
RTL, run through synthesis and implementation process before a bitstream
is created. As a prerequisite the drivers has to be installed for
corresponding XSA, for which the example was built for. Following are
the steps to build the kernel and run on a hardware:</p>
<p><em>For PCIe devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ make host xclbin TARGET=hw

$ make run TARGET=hw
</pre></div>
</div>
<p><em>For embedded devices:</em></p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>$ export SYSROOT=&lt; path-to-platform-sysroot &gt;

$ make host xclbin TARGET=hw BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;

$ make run TARGET=hw BOARD=Zynq ARCH=&lt; aarch64 | aarch32 &gt;
</pre></div>
</div>
<p><em>Note1</em>. For non-DFX platforms, BOOT.BIN has to be manually copied from &lt; build-directory &gt;/&lt; xclbin-folder &gt;/sd_card / to the top level sd_card folder.</p>
<p><em>Note2</em>. For hw run on embedded devices, copy the generated sd_card folder content under package_hw directory to an SDCARD and run the following commands on the board:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span>

<span class="n">export</span> <span class="n">XCL_BINDIR</span><span class="o">=&lt;</span> <span class="n">xclbin</span><span class="o">-</span><span class="n">folder</span><span class="o">-</span><span class="n">present</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">the</span><span class="o">-</span><span class="n">sd_card</span> <span class="o">&gt;</span> <span class="c1">#For example, &quot;export XCL_BINDIR=xclbin_zcu102_base_hw&quot;</span>

<span class="o">./&lt;</span> <span class="n">executable</span> <span class="o">&gt;</span> <span class="o">&lt;</span> <span class="n">arguments</span> <span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-the-vitis-vision-library">
<h2>Using the Vitis vision Library<a class="headerlink" href="#using-the-vitis-vision-library" title="Permalink to this headline">¶</a></h2>
<p>This section describes using the Vitis vision library in the Vitis development
environment.</p>
<p>Note: The instructions in this section assume that you have downloaded
and installed all the required packages.</p>
<p><em>include</em> folder constitutes all the necessary components to build a
Computer Vision or Image Processing pipeline using the library. The
folders <em>common</em> and <em>core</em> contain the infrastructure that the library
functions need for basic functions, Mat class, and macros. The library
functions are categorized into 4 folders, <em>features</em>, <em>video</em>, <em>dnn</em>, and
<em>imgproc</em> based on the operation they perform. The names of the folders
are self-explanatory.</p>
<p>To work with the library functions, you need to include the path to the
the <em>include</em> folder in the Vitis project. You can include relevant header files
for the library functions you will be working with after you source the
<em>include</em> folder’s path to the compiler. For example, if you would like to
work with Harris Corner Detector and Bilateral Filter, you must use the
following lines in the host code:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include “features/xf_harris.hpp” //for Harris Corner Detector</span>
<span class="c1">#include “imgproc/xf_bilateral_filter.hpp” //for Bilateral Filter</span>
<span class="c1">#include “video/xf_kalmanfilter.hpp”</span>
</pre></div>
</div>
<p>After the headers are included, you can work with the library functions
as described in the <a class="reference external" href="api-reference.html#ycb1504034263746">Vitis vision Library API
Reference</a> using the examples
in the examples folder as reference.</p>
<p>The following table gives the name of the header file, including the
folder name, which contains the library function.</p>
<table border="1" class="docutils" id="id21">
<caption><span class="caption-text">Table : Vitis Vision Library</span><a class="headerlink" href="#id21" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">File Path in the include folder</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>xf::cv::accumulate</td>
<td>imgproc/xf_accumulate_image.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::accumulateSquare</td>
<td>imgproc/xf_accumulate_squared.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::accumulateWeighted</td>
<td>imgproc/xf_accumulate_weighted.hp
p</td>
</tr>
<tr class="row-odd"><td>xf::cv::absdiff, xf::cv::add,
xf::cv::subtract, xf::cv::bitwise_and,
xf::cv::bitwise_or, xf::cv::bitwise_not,
xf::cv::bitwise_xor,xf::cv::multiply
,xf::cv::Max, xf::cv::Min,xf::cv::compare,
xf::cv::zero, xf::cv::addS, xf::cv::SubS,
xf::cv::SubRS ,xf::cv::compareS,
xf::cv::MaxS, xf::cv::MinS, xf::cv::set</td>
<td>core/xf_arithm.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::addWeighted</td>
<td>imgproc/xf_add_weighted.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::autowhitebalance</td>
<td>imgproc/xf_autowhitebalance.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::bilateralFilter</td>
<td>imgproc/xf_histogram.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::boxFilter</td>
<td>imgproc/xf_box_filter.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::boundingbox</td>
<td>imgproc/xf_boundingbox.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::badpixelcorrection</td>
<td>imgproc/xf_bpc.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::Canny</td>
<td>imgproc/xf_canny.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::Colordetect</td>
<td>imgproc/xf_colorthresholding.hpp,
imgproc/xf_bgr2hsv.hpp,
imgproc/xf_erosion.hpp,
imgproc/xf_dilation.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::merge</td>
<td>imgproc/xf_channel_combine.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::extractChannel</td>
<td>imgproc/xf_channel_extract.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::convertTo</td>
<td>imgproc/xf_convert_bitdepth.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::crop</td>
<td>imgproc/xf_crop.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::filter2D</td>
<td>imgproc/xf_custom_convolution.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::nv122iyuv, xf::cv::nv122rgba,
xf::cv::nv122yuv4, xf::cv::nv212iyuv,
xf::cv::nv212rgba, xf::cv::nv212yuv4,
xf::cv::rgba2yuv4, xf::cv::rgba2iyuv,
xf::cv::rgba2nv12, xf::cv::rgba2nv21,
xf::cv::uyvy2iyuv, xf::cv::uyvy2nv12,
xf::cv::uyvy2rgba, xf::cv::yuyv2iyuv,
xf::cv::yuyv2nv12, xf::cv::yuyv2rgba,
xf::cv::rgb2iyuv,xf::cv::rgb2nv12,
xf::cv::rgb2nv21, xf::cv::rgb2yuv4,
xf::cv::rgb2uyvy, xf::cv::rgb2yuyv,
xf::cv::rgb2bgr, xf::cv::bgr2uyvy,
xf::cv::bgr2yuyv, xf::cv::bgr2rgb,
xf::cv::bgr2nv12, xf::cv::bgr2nv21,
xf::cv::iyuv2nv12, xf::cv::iyuv2rgba,
xf::cv::iyuv2rgb, xf::cv::iyuv2yuv4,
xf::cv::nv122uyvy, xf::cv::nv122yuyv,
xf::cv::nv122nv21, xf::cv::nv212rgb,
xf::cv::nv212bgr, xf::cv::nv212uyvy,
xf::cv::nv212yuyv, xf::cv::nv212nv12,
xf::cv::uyvy2rgb, xf::cv::uyvy2bgr,
xf::cv::uyvy2yuyv, xf::cv::yuyv2rgb,
xf::cv::yuyv2bgr, xf::cv::yuyv2uyvy,
xf::cv::rgb2gray, xf::cv::bgr2gray,
xf::cv::gray2rgb, xf::cv::gray2bgr,
xf::cv::rgb2xyz, xf::cv::bgr2xyz…</td>
<td>imgproc/xf_cvt_color.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::dilate</td>
<td>imgproc/xf_dilation.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::demosaicing</td>
<td>imgproc/xf_demosaicing.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::erode</td>
<td>imgproc/xf_erosion.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::fast</td>
<td>features/xf_fast.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::GaussianBlur</td>
<td>imgproc/xf_gaussian_filter.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::gaincontrol</td>
<td>imgproc/xf_gaincontrol.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::gammacorrection</td>
<td>imgproc/xf_gammacorrection</td>
</tr>
<tr class="row-odd"><td>xf::cv::cornerHarris</td>
<td>features/xf_harris.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::calcHist</td>
<td>imgproc/xf_histogram.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::equalizeHist</td>
<td>imgproc/xf_hist_equalize.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::HOGDescriptor</td>
<td>imgproc/xf_hog_descriptor.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::Houghlines</td>
<td>imgproc/xf_houghlines.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::inRange</td>
<td>imgproc/xf_inrange.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::integralImage</td>
<td>imgproc/xf_integral_image.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::densePyrOpticalFlow</td>
<td>video/xf_pyr_dense_optical_flow.h
pp</td>
</tr>
<tr class="row-odd"><td>xf::cv::DenseNonPyrLKOpticalFlow</td>
<td>video/xf_dense_npyr_optical_flow.
hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::LUT</td>
<td>imgproc/xf_lut.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::KalmanFilter</td>
<td>video/xf_kalmanfilter.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::magnitude</td>
<td>core/xf_magnitude.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::MeanShift</td>
<td>imgproc/xf_mean_shift.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::meanStdDev</td>
<td>core/xf_mean_stddev.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::medianBlur</td>
<td>imgproc/xf_median_blur.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::minMaxLoc</td>
<td>core/xf_min_max_loc.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::OtsuThreshold</td>
<td>imgproc/xf_otsuthreshold.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::phase</td>
<td>core/xf_phase.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::preProcess</td>
<td>dnn/xf_pre_process.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::paintmask</td>
<td>imgproc/xf_paintmask.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::pyrDown</td>
<td>imgproc/xf_pyr_down.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::pyrUp</td>
<td>imgproc/xf_pyr_up.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::reduce</td>
<td>imgrpoc/xf_reduce.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::remap</td>
<td>imgproc/xf_remap.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::resize</td>
<td>imgproc/xf_resize.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::convertScaleAbs</td>
<td>imgproc/xf_convertscaleabs.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::Scharr</td>
<td>imgproc/xf_scharr.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::SemiGlobalBM</td>
<td>imgproc/xf_sgbm.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::Sobel</td>
<td>imgproc/xf_sobel.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::StereoPipeline</td>
<td>imgproc/xf_stereo_pipeline.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::sum</td>
<td>imgproc/xf_sum.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::StereoBM</td>
<td>imgproc/xf_stereoBM.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::SVM</td>
<td>imgproc/xf_svm.hpp</td>
</tr>
<tr class="row-even"><td>xf::cv::Threshold</td>
<td>imgproc/xf_threshold.hpp</td>
</tr>
<tr class="row-odd"><td>xf::cv::warpTransform</td>
<td>imgproc/xf_warp_transform.hpp</td>
</tr>
</tbody>
</table>
<div class="section" id="changing-the-hardware-kernel-configuration">
<h3>Changing the Hardware Kernel Configuration<a class="headerlink" href="#changing-the-hardware-kernel-configuration" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Update the &lt;path to vitis vision git
folder&gt;/vision/L1/examples/&lt;function&gt;/build/xf_config_params.h file.</div></blockquote>
</div>
<div class="section" id="using-the-vitis-vision-library-functions-on-hardware">
<h3>Using the Vitis vision Library Functions on Hardware<a class="headerlink" href="#using-the-vitis-vision-library-functions-on-hardware" title="Permalink to this headline">¶</a></h3>
<p>The following table lists the Vitis vision library functions and the command
to run the respective examples on hardware. It is assumed that your
design is completely built and the board has booted up correctly.</p>
<table border="1" class="docutils" id="id22">
<caption><span class="caption-text">Table : Using the Vitis vision Library Function on Hardware</span><a class="headerlink" href="#id22" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="21%" />
<col width="40%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example</th>
<th class="head">Function Name</th>
<th class="head">Usage on Hardware</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>accumulate</td>
<td>xf::cv::accumulate</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>accumulatesq
uared</td>
<td>xf::cv::accumulateSquare</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>accumulatewe
ighted</td>
<td>xf::cv::accumulateWeighted</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>addS</td>
<td>xf::cv::addS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>arithm</td>
<td>xf::cv::absdiff,
xf::cv::subtract,
xf::cv::bitwise_and,
xf::cv::bitwise_or,
xf::cv::bitwise_not,
xf::cv::bitwise_xor</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>addweighted</td>
<td>xf::cv::addWeighted</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>Autowhite
balance</td>
<td>xf::cv::autowhitebalance</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Bilateralfil
ter</td>
<td>xf::cv::bilateralFilter</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Boxfilter</td>
<td>xf::cv::boxFilter</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Badpixelcorr
ection</td>
<td>xf::cv::badpixelcorrection</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Boundingbox</td>
<td>xf::cv::boundingbox</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;
&lt;No of ROI’s&gt;</td>
</tr>
<tr class="row-odd"><td>Canny</td>
<td>xf::cv::Canny</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>channelcombi
ne</td>
<td>xf::cv::merge</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;
&lt;path to input image 3&gt;
&lt;path to input image 4&gt;</td>
</tr>
<tr class="row-odd"><td>Channelextra
ct</td>
<td>xf::cv::extractChannel</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Colordetect</td>
<td>xf::cv::bgr2hsv,
xf::cv::colorthresholding,
xf::cv:: erode, xf::cv::
dilate</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>compare</td>
<td>xf::cv::compare</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>compareS</td>
<td>xf::cv::compareS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Convertbitde
pth</td>
<td>xf::cv::convertTo</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>convertScale
Abs</td>
<td>xf::cv::convertScaleAbs</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Cornertracke
r</td>
<td>xf::cv::cornerTracker</td>
<td>./exe &lt;input video&gt; &lt;no.
of frames&gt; &lt;Harris
Threshold&gt; &lt;No. of
frames after which
Harris Corners are
Reset&gt;</td>
</tr>
<tr class="row-even"><td>crop</td>
<td>xf::cv::crop</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Customconv</td>
<td>xf::cv::filter2D</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
IYUV2NV12</td>
<td>xf::cv::iyuv2nv12</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;
&lt;path to input image 3&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
IYUV2RGBA</td>
<td>xf::cv::iyuv2rgba</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;
&lt;path to input image 3&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
IYUV2YUV4</td>
<td>xf::cv::iyuv2yuv4</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;
&lt;path to input image 3&gt;
&lt;path to input image 4&gt;
&lt;path to input image 5&gt;
&lt;path to input image 6&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
NV122IYUV</td>
<td>xf::cv::nv122iyuv</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
NV122RGBA</td>
<td>xf::cv::nv122rgba</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
NV122YUV4</td>
<td>xf::cv::nv122yuv4</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
NV212IYUV</td>
<td>xf::cv::nv212iyuv</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
NV212RGBA</td>
<td>xf::cv::nv212rgba</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
NV212YUV4</td>
<td>xf::cv::nv212yuv4</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
RGBA2YUV4</td>
<td>xf::cv::rgba2yuv4</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
RGBA2IYUV</td>
<td>xf::cv::rgba2iyuv</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
RGBA2NV12</td>
<td>xf::cv::rgba2nv12</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
RGBA2NV21</td>
<td>xf::cv::rgba2nv21</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
UYVY2IYUV</td>
<td>xf::cv::uyvy2iyuv</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
UYVY2NV12</td>
<td>xf::cv::uyvy2nv12</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
UYVY2RGBA</td>
<td>xf::cv::uyvy2rgba</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
YUYV2IYUV</td>
<td>xf::cv::yuyv2iyuv</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>cvtcolor
YUYV2NV12</td>
<td>xf::cv::yuyv2nv12</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>cvtcolor
YUYV2RGBA</td>
<td>xf::cv::yuyv2rgba</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Demosaicing</td>
<td>xf::cv::demosaicing</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Difference
of Gaussian</td>
<td>xf::cv::GaussianBlur,
xf::cv::duplicateMat,
and
xf::cv::subtract</td>
<td>./&lt;exe-name&gt;.elf &lt;path
to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Dilation</td>
<td>xf::cv::dilate</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Erosion</td>
<td>xf::cv::erode</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Fast</td>
<td>xf::cv::fast</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Gaussianfilt
er</td>
<td>xf::cv::GaussianBlur</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Gaincontrol</td>
<td>xf::cv::gaincontrol</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Gammacorrec
tion</td>
<td>xf::cv::gammacorrection</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Harris</td>
<td>xf::cv::cornerHarris</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Histogram</td>
<td>xf::cv::calcHist</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Histequializ
e</td>
<td>xf::cv::equalizeHist</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Hog</td>
<td>xf::cv::HOGDescriptor</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Houghlines</td>
<td>xf::cv::HoughLines</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>inRange</td>
<td>xf::cv::inRange</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Integralimg</td>
<td>xf::cv::integralImage</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Lkdensepyrof</td>
<td>xf::cv::densePyrOpticalFlo
w</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>Lknpyroflow</td>
<td>xf::cv::DenseNonPyr
LKOpticalFlow</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>Lut</td>
<td>xf::cv::LUT</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Kalman
Filter</td>
<td>xf::cv::KalmanFilter</td>
<td>./&lt;executable name&gt;.elf</td>
</tr>
<tr class="row-even"><td>Magnitude</td>
<td>xf::cv::magnitude</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Max</td>
<td>xf::cv::Max</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>MaxS</td>
<td>xf::cv::MaxS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>meanshifttra
cking</td>
<td>xf::cv::MeanShift</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input
video/input image files&gt;
&lt;Number of objects to
track&gt;</td>
</tr>
<tr class="row-even"><td>meanstddev</td>
<td>xf::cv::meanStdDev</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>medianblur</td>
<td>xf::cv::medianBlur</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Min</td>
<td>xf::cv::Min</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-odd"><td>MinS</td>
<td>xf::cv::MinS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Minmaxloc</td>
<td>xf::cv::minMaxLoc</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>otsuthreshol
d</td>
<td>xf::cv::OtsuThreshold</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>paintmask</td>
<td>xf::cv::paintmask</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Phase</td>
<td>xf::cv::phase</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>Pyrdown</td>
<td>xf::cv::pyrDown</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>Pyrup</td>
<td>xf::cv::pyrUp</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>reduce</td>
<td>xf::cv::reduce</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>remap</td>
<td>xf::cv::remap</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;
&lt;path to mapx data&gt;
&lt;path to mapy data&gt;</td>
</tr>
<tr class="row-even"><td>Resize</td>
<td>xf::cv::resize</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>scharrfilter</td>
<td>xf::cv::Scharr</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>set</td>
<td>xf::cv::set</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>SemiGlobalBM</td>
<td>xf::cv::SemiGlobalBM</td>
<td>./&lt;executable name&gt;.elf
&lt;path to left image&gt;
&lt;path to right image&gt;</td>
</tr>
<tr class="row-even"><td>sobelfilter</td>
<td>xf::cv::Sobel</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>stereopipeli
ne</td>
<td>xf::cv::StereoPipeline</td>
<td>./&lt;executable name&gt;.elf
&lt;path to left image&gt;
&lt;path to right image&gt;</td>
</tr>
<tr class="row-even"><td>stereolbm</td>
<td>xf::cv::StereoBM</td>
<td>./&lt;executable name&gt;.elf
&lt;path to left image&gt;
&lt;path to right image&gt;</td>
</tr>
<tr class="row-odd"><td>subRS</td>
<td>xf::cv::SubRS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>subS</td>
<td>xf::cv::SubS</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>sum</td>
<td>xf::cv::sum</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image 1&gt;
&lt;path to input image 2&gt;</td>
</tr>
<tr class="row-even"><td>Svm</td>
<td>xf::cv::SVM</td>
<td>./&lt;executable name&gt;.elf</td>
</tr>
<tr class="row-odd"><td>threshold</td>
<td>xf::cv::Threshold</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-even"><td>warptransfor
m</td>
<td>xf::cv::warpTransform</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
<tr class="row-odd"><td>zero</td>
<td>xf::cv::zero</td>
<td>./&lt;executable name&gt;.elf
&lt;path to input image&gt;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="getting-started-with-hls">
<h1>Getting Started with HLS<a class="headerlink" href="#getting-started-with-hls" title="Permalink to this headline">¶</a></h1>
<p>The Vitis vision library can be used to build applications in Vivado® HLS as well as Vitis HLS.
This section provides details on how the Vitis vision library components can
be integrated into a design in Vivado HLS or Vitis HLS 2020.1. This section of the
document provides steps on how to run a single library component through
the Vivado HLS or Vitis HLS 2020.1 flow which includes, C-simulation,
C-synthesis, C/RTL co-simulation, and exporting the RTL as an IP.</p>
<p>You are required to do the following changes to facilitate proper
functioning of the use model in Vivado HLS 2020.1. This is not applicable when using
Vitis HLS.:</p>
<ol class="arabic simple">
<li>Use of appropriate compile-time options - When using the Vitis vision
functions in Vivado HLS, the <code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code> option
need to be provided as a compilation flag.</li>
</ol>
<div class="section" id="hls-standalone-mode">
<h2>HLS Standalone Mode<a class="headerlink" href="#hls-standalone-mode" title="Permalink to this headline">¶</a></h2>
<p>The HLS standalone mode can be operated using the following two modes:</p>
<ol class="arabic simple">
<li>Tcl Script Mode</li>
<li>GUI Mode</li>
</ol>
<div class="section" id="tcl-script-mode">
<h3>Tcl Script Mode<a class="headerlink" href="#tcl-script-mode" title="Permalink to this headline">¶</a></h3>
<p>Use the following steps to operate the HLS Standalone Mode using Tcl
Script. The first 2 steps are applicable to Vivado HLS only:</p>
<ol class="arabic simple">
<li>In the Vivado® HLS tcl script file, update the cflags in all the
add_files sections.</li>
<li>Add the <code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code> compiler flags.</li>
<li>Append the path to the vision/L1/include directory, as it contains all
the header files required by the library.</li>
</ol>
<p>Note: When using Vivado HLS in the Windows operating system, provide the
<code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code> flag only for C-Sim and Co-Sim. Do not include the flag
when performing synthesis.</p>
<p>For example:</p>
<p>Setting flags for source files:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_files</span> <span class="n">xf_dilation_accel</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">cflags</span> <span class="s2">&quot;-I&lt;path-to-include-directory&gt; -std=c++0x&quot;</span>
</pre></div>
</div>
<p>Setting flags for testbench files:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add_files</span> <span class="o">-</span><span class="n">tb</span> <span class="n">xf_dilation_tb</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">cflags</span> <span class="s2">&quot;-I&lt;path-to-include-directory&gt; -std=c++0x&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="gui-mode">
<h3>GUI Mode<a class="headerlink" href="#gui-mode" title="Permalink to this headline">¶</a></h3>
<p>Use the following steps to operate the HLS Standalone Mode using GUI:</p>
<ol class="arabic">
<li><p class="first">Open Vivado® HLS or Vitis HLS in GUI mode and create a new project</p>
</li>
<li><p class="first">Specify the name of the project. For example - Dilation.</p>
</li>
<li><p class="first">Click Browse to enter a workspace folder used to store your projects.</p>
</li>
<li><p class="first">Click Next.</p>
</li>
<li><p class="first">Under the source files section, add the accel.cpp file which can be
found in the examples folder. Also, fill the top function name (here
it is dilation_accel).</p>
</li>
<li><p class="first">Click Next.</p>
</li>
<li><p class="first">Under the test bench section add tb.cpp.</p>
</li>
<li><p class="first">Click Next.</p>
</li>
<li><p class="first">Select the clock period to the required value (10ns in example).</p>
</li>
<li><p class="first">Select the suitable part. For example, <code class="docutils literal notranslate"><span class="pre">xczu9eg-ffvb1156-2-i</span></code>.</p>
</li>
<li><p class="first">Click Finish.</p>
</li>
<li><p class="first">Right click on the created project and select Project Settings.</p>
</li>
<li><p class="first">In the opened tab, select Simulation.</p>
</li>
<li><p class="first">Files added under the Test Bench section will be displayed. Select a
file and click Edit CFLAGS.</p>
</li>
<li><p class="first">Enter
<code class="docutils literal notranslate"><span class="pre">-I&lt;path-to-include-directory&gt;</span> <span class="pre">-std=c++0x</span></code>.</p>
<p>Note: When using Vivado HLS in the Windows operating system, make
sure to provide the <code class="docutils literal notranslate"><span class="pre">-std=c++0x</span></code> flag only for C-Sim and Co-Sim. Do
not include the flag when performing synthesis.</p>
</li>
<li><p class="first">Select Synthesis and repeat the above step for all the displayed
files.</p>
</li>
<li><p class="first">Click OK.</p>
</li>
<li><p class="first">Run the C Simulation, select Clean Build and specify the required
input arguments.</p>
</li>
<li><p class="first">Click OK.</p>
</li>
<li><p class="first">All the generated output files/images will be present in the
solution1-&gt;csim-&gt;build.</p>
</li>
<li><p class="first">Run C synthesis.</p>
</li>
<li><p class="first">Run co-simulation by specifying the proper input arguments.</p>
</li>
<li><p class="first">The status of co-simulation can be observed on the console.</p>
</li>
</ol>
</div>
<div class="section" id="constraints-for-co-simulation">
<h3>Constraints for Co-simulation<a class="headerlink" href="#constraints-for-co-simulation" title="Permalink to this headline">¶</a></h3>
<p>There are few limitations in performing co-simulation of the Vitis vision
functions. They are:</p>
<ol class="arabic simple">
<li>Functions with multiple accelerators are not supported.</li>
<li>Compiler and simulator are default in HLS (gcc, xsim).</li>
<li>Since HLS does not support multi-kernel integration, the current flow
also does not support multi-kernel integration. Hence, the Pyramidal
Optical flow and Canny Edge Detection functions and examples are not
supported in this flow.</li>
<li>The maximum image size (HEIGHT and WIDTH) set in config.h file should
be equal to the actual input image size.</li>
</ol>
</div>
</div>
<div class="section" id="axi-video-interface-functions">
<h2>AXI Video Interface Functions<a class="headerlink" href="#axi-video-interface-functions" title="Permalink to this headline">¶</a></h2>
<p>Vitis vision has functions that will transform the xf::cv::Mat into Xilinx®
Video Streaming interface and vice-versa. <code class="docutils literal notranslate"><span class="pre">xf::cv::AXIvideo2xfMat()</span></code> and
<code class="docutils literal notranslate"><span class="pre">xf::cv::xfMat2AXIVideo()</span></code> act as video interfaces to the IPs of the
Vitis vision functions in the Vivado® IP integrator.
<code class="docutils literal notranslate"><span class="pre">cvMat2AXIvideoxf&lt;NPC&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">AXIvideo2cvMatxf&lt;NPC&gt;</span></code>
are used on the host side.</p>
<table border="1" class="docutils" id="id23">
<caption><span class="caption-text">Table. AXI Video Interface Functions</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Video Library Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AXIvideo2xfMat</td>
<td>Converts data from an AXI4 video stream
representation to xf::cv::Mat format.</td>
</tr>
<tr class="row-odd"><td>xfMat2AXIvideo</td>
<td>Converts data stored as xf::cv::Mat
format to an AXI4 video stream.</td>
</tr>
<tr class="row-even"><td>cvMat2AXIvideoxf</td>
<td>Converts data stored as cv::Mat format
to an AXI4 video stream</td>
</tr>
<tr class="row-odd"><td>AXIvideo2cvMatxf</td>
<td>Converts data from an AXI4 video stream
representation to cv::Mat format.</td>
</tr>
</tbody>
</table>
<div class="section" id="axivideo2xfmat">
<h3>AXIvideo2xfMat<a class="headerlink" href="#axivideo2xfmat" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">AXIvideo2xfMat</span></code> function receives a sequence of images using the
AXI4 Streaming Video and produces an <code class="docutils literal notranslate"><span class="pre">xf::cv::Mat</span></code> representation.</p>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">W</span><span class="p">,</span><span class="nb">int</span> <span class="n">T</span><span class="p">,</span><span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span><span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="nb">int</span> <span class="n">AXIvideo2xfMat</span><span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span> <span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">W</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">AXI_video_strm</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id24">
<caption><span class="caption-text">Table. AXIvideo2cvMatxf Function Parameter Description</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td>Data width of AXI4-Stream.
Recommended value is pixel depth.</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Pixel type of the image. 1
channel (XF_8UC1). Data width of
pixel must be no greater than W.</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input image.</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input image.</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed
per cycle. Possible options are
XF_NPPC1 and XF_NPPC8 for 1-pixel
and 8-pixel operations
respectively.</td>
</tr>
<tr class="row-odd"><td>AXI_video_strm</td>
<td>HLS stream of ap_axiu (axi
protocol) type.</td>
</tr>
<tr class="row-even"><td>img</td>
<td>Input image.</td>
</tr>
</tbody>
</table>
<p>This function will return bit error of ERROR_IO_EOL_EARLY( 1 ) or
ERROR_IO_EOL_LATE( 2 ) to indicate an unexpected line length, by
detecting TLAST input.</p>
<p>For more information about AXI interface see UG761.</p>
</div>
<div class="section" id="xfmat2axivideo">
<h3>xfMat2AXIvideo<a class="headerlink" href="#xfmat2axivideo" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Mat2AXI</span></code> video function receives an xf::cv::Mat representation of a
sequence of images and encodes it correctly using the AXI4 Streaming
video protocol.</p>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">W</span><span class="p">,</span> <span class="nb">int</span> <span class="n">T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span><span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="nb">int</span> <span class="n">xfMat2AXIvideo</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">img</span><span class="p">,</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">W</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">AXI_video_strm</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id25">
<caption><span class="caption-text">Table. xfMat2AXIvideo Function Parameter Description</span><a class="headerlink" href="#id25" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td>Data width of AXI4-Stream.
Recommended value is pixel depth.</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Pixel type of the image. 1
channel (XF_8UC1). Data width of
pixel must be no greater than W.</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input image.</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input image.</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed
per cycle. Possible options are
XF_NPPC1 and XF_NPPC8 for 1-pixel
and 8-pixel operations
respectively.</td>
</tr>
<tr class="row-odd"><td>AXI_video_strm</td>
<td>HLS stream of ap_axiu (axi
protocol) type.</td>
</tr>
<tr class="row-even"><td>img</td>
<td>Output image.</td>
</tr>
</tbody>
</table>
<p>This function returns the value 0.</p>
<p>Note: The NPC values across all the functions in a data flow must follow
the same value. If there is mismatch it throws a compilation error in
HLS.</p>
</div>
<div class="section" id="cvmat2axivideoxf">
<h3>cvMat2AXIvideoxf<a class="headerlink" href="#cvmat2axivideoxf" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cvMat2Axivideoxf</span></code> function receives image as cv::Mat
representation and produces the AXI4 streaming video of image.</p>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span><span class="nb">int</span> <span class="n">W</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cvMat2AXIvideoxf</span><span class="p">(</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">cv_mat</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">W</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">AXI_video_strm</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id26">
<caption><span class="caption-text">Table. AXIvideo2cvMatxf Function Parameter Description</span><a class="headerlink" href="#id26" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td>Data width of AXI4-Stream.
Recommended value is pixel depth.</td>
</tr>
<tr class="row-odd"><td>NPC</td>
<td>Number of pixels to be processed
per cycle. Possible options are
XF_NPPC1 and XF_NPPC8 for 1-pixel
and 8-pixel operations
respectively.</td>
</tr>
<tr class="row-even"><td>AXI_video_strm</td>
<td>HLS stream of ap_axiu (axi
protocol) type.</td>
</tr>
<tr class="row-odd"><td>cv_mat</td>
<td>Input image.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="axivideo2cvmatxf">
<h3>AXIvideo2cvMatxf<a class="headerlink" href="#axivideo2cvmatxf" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Axivideo2cvMatxf</span></code> function receives image as AXI4 streaming video
and produces the cv::Mat representation of image</p>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span><span class="nb">int</span> <span class="n">W</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">AXIvideo2cvMatxf</span><span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">W</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">AXI_video_strm</span><span class="p">,</span> <span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">cv_mat</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id27">
<caption><span class="caption-text">Table. AXIvideo2cvMatxf Function Parameter Description</span><a class="headerlink" href="#id27" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td>Data width of AXI4-Stream.
Recommended value is pixel depth.</td>
</tr>
<tr class="row-odd"><td>NPC</td>
<td>Number of pixels to be processed
per cycle. Possible options are
XF_NPPC1 and XF_NPPC8 for 1-pixel
and 8-pixel operations
respectively.</td>
</tr>
<tr class="row-even"><td>AXI_video_strm</td>
<td>HLS stream of ap_axiu (axi
protocol) type.</td>
</tr>
<tr class="row-odd"><td>cv_mat</td>
<td>Output image.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="migrating-hls-video-library-to-vitis-vision">
<h2>Migrating HLS Video Library to Vitis vision<a class="headerlink" href="#migrating-hls-video-library-to-vitis-vision" title="Permalink to this headline">¶</a></h2>
<p>The HLS video library has been deprecated. All the functions and
most of the infrastructure available in HLS video library are now
available in Vitis vision with their names changed and some modifications.
These HLS video library functions ported to Vitis vision supports build
flow also.</p>
<p>This section provides the details on using the C++ video processing
functions and the infrastructure present in HLS video library.</p>
<div class="section" id="infrastructure-functions-and-classes">
<h3>Infrastructure Functions and Classes<a class="headerlink" href="#infrastructure-functions-and-classes" title="Permalink to this headline">¶</a></h3>
<p>All the functions imported from HLS video library now take xf::cv::Mat (in
sync with Vitis vision library) to represent image data instead of hls::Mat.
The main difference between these two is that the hls::Mat uses
hls::stream to store the data whereas xf::cv::Mat uses a pointer. Therefore,
hls:: Mat cannot be exactly replaced with xf::cv::Mat for migrating.</p>
<p>Below table summarizes the differences between member functions of
hls::Mat to xf::cv::Mat.</p>
<table border="1" class="docutils" id="id28">
<caption><span class="caption-text">Table : Infrastructure Functions and Classes</span><a class="headerlink" href="#id28" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="31%" />
<col width="31%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Member Function</th>
<th class="head">hls::Mat (HLS Video
lib)</th>
<th class="head">xf::cv::Mat (Vitis vision
lib)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>channels()</td>
<td>Returns the number
of channels</td>
<td>Returns the number
of channels</td>
</tr>
<tr class="row-odd"><td>type()</td>
<td>Returns the enum
value of pixel type</td>
<td>Returns the enum
value of pixel type</td>
</tr>
<tr class="row-even"><td>depth()</td>
<td>Returns the enum
value of pixel type</td>
<td>Returns the depth of
pixel including
channels</td>
</tr>
<tr class="row-odd"><td>read()</td>
<td>Readout a value and
return it as a
scalar from stream</td>
<td>Readout a value from
a given location and
return it as a
packed (for
multi-pixel/clock)
value.</td>
</tr>
<tr class="row-even"><td>operator &gt;&gt;</td>
<td>Similar to read()</td>
<td>Not available in
Vitis vision</td>
</tr>
<tr class="row-odd"><td>operator &lt;&lt;</td>
<td>Similar to write()</td>
<td>Not available in
Vitis vision</td>
</tr>
<tr class="row-even"><td>Write()</td>
<td>Write a scalar value
into the stream</td>
<td>Writes a packed (for
multi-pixel/clock)
value into the given
location.</td>
</tr>
</tbody>
</table>
<p>Infrastructure files available in HLS Video Library hls_video_core.hpp,
hls_video_mem.hpp, hls_video_types.hpp are moved to xf_video_core.hpp,
xf_video_mem.hpp, xf_video_types.hpp in Vitis vision Library and
hls_video_imgbase.hpp is deprecated. Code inside these files unchanged
except that these are now under xf::cv::namespace.</p>
</div>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Memory Window Buffer</dt>
<dd>hls::window is now xf::cv::window. No change in the implementation,
except the namespace change. This is located in “xf_video_mem.h”
file.</dd>
<dt>Memory Line Buffer</dt>
<dd>hls::LineBuffer is now xf::cv::LineBuffer. No difference between the two,
except xf::cv::LineBuffer has extra template arguments for inferring
different types of RAM structures, for the storage structure used.
Default storage type is “RAM_S2P_BRAM” with RESHAPE_FACTOR=1.
Complete description can be found here
<a class="reference external" href="MigratingHLSVideoLibrarytoVitisvision.html#ndi1542884914646">xf::cv::LineBuffer</a>. This is
located in xf_video_mem.hpp file.</dd>
</dl>
</div>
<div class="section" id="funtions">
<h3>Funtions<a class="headerlink" href="#funtions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>OpenCV interface functions</dt>
<dd>These functions covert image data of OpenCV Mat format to/from HLS
AXI types. HLS Video Library had 14 interface functions, out of
which, two functions are available in Vitis vision Library:
cvMat2AXIvideo and AXIvideo2cvMat located in “xf_axi.h” file. The
rest are all deprecated.</dd>
<dt>AXI4-Stream I/O Functions</dt>
<dd>The I/O functions which convert hls::Mat to/from AXI4-Stream
compatible data type (hls::stream) are hls::AXIvideo2Mat,
hls::Mat2AXIvideo. These functions are now deprecated and added 2 new
functions xf::cv::AXIvideo2xfMat and xf::cv:: xfMat2AXIvideo to facilitate
the xf::cv::Mat to/from conversion. To use these functions, the header
file “xf_infra.hpp” must be included.</dd>
</dl>
</div>
<div class="section" id="xf-cv-window">
<h3>xf::cv::window<a class="headerlink" href="#xf-cv-window" title="Permalink to this headline">¶</a></h3>
<p>A template class to represent the 2D window buffer. It has three
parameters to specify the number of rows, columns in window buffer and
the pixel data type.</p>
<div class="section" id="class-definition">
<h4>Class definition<a class="headerlink" href="#class-definition" title="Permalink to this headline">¶</a></h4>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Window</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">Window</span><span class="p">()</span>
   <span class="o">/*</span> <span class="n">Window</span> <span class="n">main</span> <span class="n">APIs</span> <span class="o">*/</span>
    <span class="n">void</span> <span class="n">shift_pixels_left</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">shift_pixels_right</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">shift_pixels_up</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">shift_pixels_down</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">insert_pixel</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_row</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">COLS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">row</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_top_row</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">COLS</span><span class="p">]);</span>
    <span class="n">void</span> <span class="n">insert_bottom_row</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">COLS</span><span class="p">]);</span>
    <span class="n">void</span> <span class="n">insert_col</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">ROWS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_left_col</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">ROWS</span><span class="p">]);</span>
    <span class="n">void</span> <span class="n">insert_right_col</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">ROWS</span><span class="p">]);</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">getval</span><span class="p">(</span><span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="p">()(</span><span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">val</span><span class="p">[</span><span class="n">ROWS</span><span class="p">][</span><span class="n">COLS</span><span class="p">];</span>
<span class="c1">#ifdef __DEBUG__</span>
    <span class="n">void</span> <span class="n">restore_val</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">window_print</span><span class="p">();</span>
    <span class="n">T</span> <span class="n">val_t</span><span class="p">[</span><span class="n">ROWS</span><span class="p">][</span><span class="n">COLS</span><span class="p">];</span>
<span class="c1">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-descriptions">
<h4>Parameter Descriptions<a class="headerlink" href="#parameter-descriptions" title="Permalink to this headline">¶</a></h4>
<p>The following table lists the xf::cv::Window class members and their
descriptions.</p>
<table border="1" class="docutils" id="id29">
<caption><span class="caption-text">Table : Window Function Parameter Descriptions</span><a class="headerlink" href="#id29" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Val</td>
<td>2-D array to hold the contents of buffer.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="member-function-description">
<h4>Member Function Description<a class="headerlink" href="#member-function-description" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="id30">
<caption><span class="caption-text">Table : Member Function Description</span><a class="headerlink" href="#id30" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shift_pixels_left()</td>
<td>Shift the window left, that moves
all stored data within the window
right, leave the leftmost column
(col = COLS-1) for inserting new
data.</td>
</tr>
<tr class="row-odd"><td>shift_pixels_right()</td>
<td>Shift the window right, that
moves all stored data within the
window left, leave the rightmost
column (col = 0) for inserting
new data.</td>
</tr>
<tr class="row-even"><td>shift_pixels_up()</td>
<td>Shift the window up, that moves
all stored data within the window
down, leave the top row (row =
ROWS-1) for inserting new data.</td>
</tr>
<tr class="row-odd"><td>shift_pixels_down()</td>
<td>Shift the window down, that moves
all stored data within the window
up, leave the bottom row (row =
0) for inserting new data.</td>
</tr>
<tr class="row-even"><td>insert_pixel(T value, int row,
int col)</td>
<td>Insert a new element value at
location (row, column) of the
window.</td>
</tr>
<tr class="row-odd"><td>insert_row(T value[COLS], int
row)</td>
<td>Inserts a set of values in any
row of the window.</td>
</tr>
<tr class="row-even"><td>insert_top_row(T value[COLS])</td>
<td>Inserts a set of values in the
top row = 0 of the window.</td>
</tr>
<tr class="row-odd"><td>insert_bottom_row(T value[COLS])</td>
<td>Inserts a set of values in the
bottom row = ROWS-1 of the
window.</td>
</tr>
<tr class="row-even"><td>insert_col(T value[ROWS], int
col)</td>
<td>Inserts a set of values in any
column of the window.</td>
</tr>
<tr class="row-odd"><td>insert_left_col(T value[ROWS])</td>
<td>Inserts a set of values in left
column = 0 of the window.</td>
</tr>
<tr class="row-even"><td>insert_right_col(T value[ROWS])</td>
<td>Inserts a set of values in right
column = COLS-1 of the window.</td>
</tr>
<tr class="row-odd"><td>T&amp; getval(int row, int col)</td>
<td>Returns the data value in the
window at position (row,column).</td>
</tr>
<tr class="row-even"><td>T&amp; operator ()(int row, int col)</td>
<td>Returns the data value in the
window at position (row,column).</td>
</tr>
<tr class="row-odd"><td>restore_val()</td>
<td>Restore the contents of window
buffer to another array.</td>
</tr>
<tr class="row-even"><td>window_print()</td>
<td>Print all the data present in
window buffer onto console.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-parameter-description">
<h4>Template Parameter Description<a class="headerlink" href="#template-parameter-description" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="id31">
<caption><span class="caption-text">Table : Template Parameter Description</span><a class="headerlink" href="#id31" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ROWS</td>
<td>Number of rows in the window buffer.</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Number of columns in the window buffer.</td>
</tr>
<tr class="row-even"><td>T</td>
<td>Data type of pixel in the window buffer.</td>
</tr>
</tbody>
</table>
<p>Sample code for window buffer declaration</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Window</span><span class="o">&lt;</span><span class="n">K_ROWS</span><span class="p">,</span> <span class="n">K_COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">char</span><span class="o">&gt;</span> <span class="n">kernel</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="xf-cv-linebuffer">
<span id="ariaid-title5"></span><h3>xf::cv::LineBuffer<a class="headerlink" href="#xf-cv-linebuffer" title="Permalink to this headline">¶</a></h3>
<p>A template class to represent 2D line buffer. It has three parameters to
specify the number of rows, columns in window buffer and the pixel data
type.</p>
<div class="section" id="class-definition-1">
<span id="id4"></span><h4>Class definition<a class="headerlink" href="#class-definition-1" title="Permalink to this headline">¶</a></h4>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">XF_ramtype_e</span> <span class="n">MEM_TYPE</span><span class="o">=</span><span class="n">RAM_S2P_BRAM</span><span class="p">,</span> <span class="nb">int</span> <span class="n">RESHAPE_FACTOR</span><span class="o">=</span><span class="mi">1</span><span class="o">&gt;</span>
 <span class="k">class</span> <span class="nc">LineBuffer</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">LineBuffer</span><span class="p">()</span>
       <span class="o">/*</span> <span class="n">LineBuffer</span> <span class="n">main</span> <span class="n">APIs</span> <span class="o">*/</span>
    <span class="o">/*</span> <span class="n">LineBuffer</span> <span class="n">main</span> <span class="n">APIs</span> <span class="o">*/</span>
    <span class="n">void</span> <span class="n">shift_pixels_up</span><span class="p">(</span><span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">shift_pixels_down</span><span class="p">(</span><span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_bottom_row</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_top_row</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">get_col</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">[</span><span class="n">ROWS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">getval</span><span class="p">(</span><span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="p">()(</span><span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">Back</span> <span class="n">compatible</span> <span class="n">APIs</span> <span class="o">*/</span>
    <span class="n">void</span> <span class="n">shift_up</span><span class="p">(</span><span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">shift_down</span><span class="p">(</span><span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_bottom</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">insert_top</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">val</span><span class="p">[</span><span class="n">ROWS</span><span class="p">][</span><span class="n">COLS</span><span class="p">];</span>
<span class="c1">#ifdef __DEBUG__</span>
    <span class="n">void</span> <span class="n">restore_val</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">linebuffer_print</span><span class="p">(</span><span class="nb">int</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">val_t</span><span class="p">[</span><span class="n">ROWS</span><span class="p">][</span><span class="n">COLS</span><span class="p">];</span>
<span class="c1">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-descriptions-1">
<span id="id5"></span><h4>Parameter Descriptions<a class="headerlink" href="#parameter-descriptions-1" title="Permalink to this headline">¶</a></h4>
<p>The following table lists the xf::cv::LineBuffer class members and their
descriptions.</p>
<table border="1" class="docutils" id="id32">
<caption><span class="caption-text">Table : Line Buffer Function Parameter Descriptions</span><a class="headerlink" href="#id32" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Val</td>
<td>2-D array to hold the contents of line buffer.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="member-functions-description">
<h4>Member Functions Description<a class="headerlink" href="#member-functions-description" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="id33">
<caption><span class="caption-text">Table : Member Functions Description</span><a class="headerlink" href="#id33" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shift_pixels_up(int col)</td>
<td>Line buffer contents Shift up,
new values will be placed in the
bottom row=ROWS-1.</td>
</tr>
<tr class="row-odd"><td>shift_pixels_down(int col)</td>
<td>Line buffer contents Shift down,
new values will be placed in the
top row=0.</td>
</tr>
<tr class="row-even"><td>insert_bottom_row(T value, int
col)</td>
<td>Inserts a new value in bottom
row= ROWS-1 of the line buffer.</td>
</tr>
<tr class="row-odd"><td>insert_top_row(T value, int col)</td>
<td>Inserts a new value in top row=0
of the line buffer.</td>
</tr>
<tr class="row-even"><td>get_col(T value[ROWS], int col)</td>
<td>Get a column value of the line
buffer.</td>
</tr>
<tr class="row-odd"><td>T&amp; getval(int row, int col)</td>
<td>Returns the data value in the
line buffer at position (row,
column).</td>
</tr>
<tr class="row-even"><td>T&amp; operator ()(int row, int col);</td>
<td>Returns the data value in the
line buffer at position (row,
column).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-parameter-description-1">
<span id="id6"></span><h4>Template Parameter Description<a class="headerlink" href="#template-parameter-description-1" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="id34">
<caption><span class="caption-text">Table : Template Parameter Description</span><a class="headerlink" href="#id34" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ROWS</td>
<td>Number of rows in line buffer.</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Number of columns in line buffer.</td>
</tr>
<tr class="row-even"><td>T</td>
<td>Data type of pixel in line
buffer.</td>
</tr>
<tr class="row-odd"><td>MEM_TYPE</td>
<td>Type of storage element. It takes
one of the following enumerated
values: RAM_1P_BRAM, RAM_1P_URAM,
RAM_2P_BRAM, RAM_2P_URAM,
RAM_S2P_BRAM, RAM_S2P_URAM,
RAM_T2P_BRAM, RAM_T2P_URAM.</td>
</tr>
<tr class="row-even"><td>RESHAPE_FACTOR</td>
<td>Specifies the amount to divide an
array.</td>
</tr>
</tbody>
</table>
<p>Sample code for line buffer declaration:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LineBuffer</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="n">XF_8UC3</span><span class="p">,</span> <span class="n">RAM_S2P_URAM</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>     <span class="n">buff</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="video-processing-functions">
<span id="ariaid-title6"></span><h3>Video Processing Functions<a class="headerlink" href="#video-processing-functions" title="Permalink to this headline">¶</a></h3>
<p>The following table summarizes the video processing functions ported
from HLS Video Library into Vitis vision Library along with the API
modifications.</p>
<table border="1" class="docutils" id="id35">
<caption><span class="caption-text">Table : Video Processing Functions</span><a class="headerlink" href="#id35" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="8%" />
<col width="39%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Functions</th>
<th class="head">HLS Video Library -API</th>
<th class="head">xfOpenCV Library-API</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>addS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p class="last">void AddS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp;src,Scalar&lt;HLS_MAT_CN(SRC_T), _T&gt; scl, Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int POLICY_TYPE, int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void addS(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>AddWeighted</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T&gt;</p>
<p class="last">void AddWeighted(Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,P_T alpha,Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,P_T beta, P_T gamma,Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T,int DST_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void addWeighted(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src1,float alpha, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src2,float beta, float gama, xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; dst)</p>
</td>
</tr>
<tr class="row-even"><td>Cmp</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void Cmp(Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst,int cmp_op)</p>
</td>
<td><p class="first">template&lt;int CMP_OP, int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void compare(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src2,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>CmpS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename P_T, int DST_T&gt;</p>
<p class="last">void CmpS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src, P_T value, Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst, int cmp_op)</p>
</td>
<td><p class="first">template&lt;int CMP_OP, int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void compare(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>Max</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void Max(Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void Max(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src2,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>MaxS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p>void MaxS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p class="last">_T value, Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void max(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>Min</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void Min(Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void Min(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src2,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>MinS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p>void MinS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p class="last">_T value,Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void min(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>PaintMask</td>
<td><p class="first">template&lt;int SRC_T,int MASK_T,int ROWS,int COLS&gt;</p>
<p>void PaintMask(</p>
<p>Mat&lt;ROWS,COLS,SRC_T&gt; &amp;_src,</p>
<p>Mat&lt;ROWS,COLS,MASK_T&gt;&amp;_mask,</p>
<p class="last">Mat&lt;ROWS,COLS,SRC_T&gt;&amp;_dst,Scalar&lt;HLS_MAT_CN(SRC_T),HLS_TNAME(SRC_T)&gt; _color)</p>
</td>
<td><p class="first">template&lt; int SRC_T,int MASK_T, int ROWS, int COLS,int NPC=1&gt;</p>
<p class="last">void paintmask(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat, xf::Mat&lt;MASK_T, ROWS, COLS, NPC&gt; &amp; in_mask, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst_mat, unsigned char _color[XF_CHANNELS(SRC_T,NPC)])</p>
</td>
</tr>
<tr class="row-odd"><td>Reduce</td>
<td><p class="first">template&lt;typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T&gt;</p>
<p>void Reduce(</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt; &amp;src,</p>
<p>Mat&lt;DST_ROWS, DST_COLS, DST_T&gt; &amp;dst,</p>
<p>int dim,</p>
<p class="last">int op=HLS_REDUCE_SUM)</p>
</td>
<td><p class="first">template&lt; int REDUCE_OP, int SRC_T,int DST_T, int ROWS, int COLS,int ONE_D_HEIGHT, int ONE_D_WIDTH, int NPC=1&gt;</p>
<p class="last">void reduce(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat, xf::Mat&lt;DST_T, ONE_D_HEIGHT, ONE_D_WIDTH, 1&gt; &amp; _dst_mat, unsigned char dim)</p>
</td>
</tr>
<tr class="row-even"><td>Zero</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p>void Zero(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void zero(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>Sum</td>
<td><p class="first">template&lt;typename DST_T, int ROWS, int COLS, int SRC_T&gt;</p>
<p>Scalar&lt;HLS_MAT_CN(SRC_T), DST_T&gt; Sum(</p>
<p class="last">Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void sum(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src1, double sum[XF_CHANNELS(SRC_T,NPC)] )</p>
</td>
</tr>
<tr class="row-even"><td>SubS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p>void SubS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Scalar&lt;HLS_MAT_CN(SRC_T), _T&gt; scl,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int POLICY_TYPE, int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void SubS(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>SubRS</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p>void SubRS(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Scalar&lt;HLS_MAT_CN(SRC_T), _T&gt; scl,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int POLICY_TYPE, int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void SubRS(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>Set</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename _T, int DST_T&gt;</p>
<p>void Set(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Scalar&lt;HLS_MAT_CN(SRC_T), _T&gt; scl,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt; int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void set(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, unsigned char _scl[XF_CHANNELS(SRC_T,NPC)],xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-odd"><td>Absdiff</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void AbsDiff(</p>
<p>Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS, int NPC =1&gt;</p>
<p class="last">void absdiff(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src2,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>And</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void And(</p>
<p>Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void bitwise_and(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src2, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp;_dst)</p>
</td>
</tr>
<tr class="row-odd"><td>Dilate</td>
<td><p class="first">template&lt;int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH&gt;</p>
<p class="last">void Dilate(Mat&lt;IMG_HEIGHT, IMG_WIDTH, SRC_T&gt;&amp;_src,Mat&lt;IMG_HEIGHT, IMG_WIDTH, DST_T&amp;_dst,Window&lt;K_HEIGHT,K_WIDTH,KN_T&gt;&amp;_kernel)</p>
</td>
<td><p class="first">template&lt;int BORDER_TYPE, int TYPE, int ROWS, int COLS,int K_SHAPE,int K_ROWS,int K_COLS, int ITERATIONS, int NPC=1&gt;</p>
<p class="last">void dilate (xf::Mat&lt;TYPE, ROWS, COLS, NPC&gt; &amp; _src, xf::Mat&lt;TYPE, ROWS, COLS, NPC&gt; &amp; _dst,unsigned char _kernel[K_ROWS*K_COLS])</p>
</td>
</tr>
<tr class="row-even"><td>Duplicate</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p class="last">void Duplicate(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst1,Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst2)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS,int NPC&gt;</p>
<p class="last">void duplicateMat(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst1,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst2)</p>
</td>
</tr>
<tr class="row-odd"><td>EqualizeHist</td>
<td><p class="first">template&lt;int SRC_T, int DST_T,int ROW, int COL&gt;</p>
<p class="last">void EqualizeHist(Mat&lt;ROW, COL, SRC_T&gt;&amp;_src,Mat&lt;ROW, COL, DST_T&gt;&amp;_dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void equalizeHist(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src1,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>erode</td>
<td><p class="first">template&lt;int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH&gt;</p>
<p class="last">void Erode(Mat&lt;IMG_HEIGHT, IMG_WIDTH, SRC_T&gt;&amp;_src,Mat&lt;IMG_HEIGHT,IMG_WIDTH,DST_T&gt;&amp;_dst,Window&lt;K_HEIGHT,K_WIDTH,KN_T&gt;&amp;_kernel)</p>
</td>
<td><p class="first">template&lt;int BORDER_TYPE, int TYPE, int ROWS, int COLS,int K_SHAPE,int K_ROWS,int K_COLS, int ITERATIONS, int NPC=1&gt;</p>
<p class="last">void erode (xf::Mat&lt;TYPE, ROWS, COLS, NPC&gt; &amp; _src, xf::Mat&lt;TYPE, ROWS, COLS, NPC&gt; &amp; _dst,unsigned char _kernel[K_ROWS*K_COLS])</p>
</td>
</tr>
<tr class="row-odd"><td>FASTX</td>
<td><p class="first">template&lt;int SRC_T,int ROWS,int COLS&gt;</p>
<p>void FASTX(Mat&lt;ROWS,COLS,SRC_T&gt; &amp;_src,</p>
<p class="last">Mat&lt;ROWS,COLS,HLS_8UC1&gt;&amp;_mask,HLS_TNAME(SRC_T)_threshold,bool _nomax_supression)</p>
</td>
<td><p class="first">template&lt;int NMS,int SRC_T,int ROWS, int COLS,int NPC=1&gt;</p>
<p class="last">void fast(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst_mat,unsigned char _threshold)</p>
</td>
</tr>
<tr class="row-even"><td>Filter2D</td>
<td><p class="first">template&lt;int SRC_T, int DST_T, typename KN_T, typename POINT_T,</p>
<p>int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH&gt;</p>
<p class="last">void Filter2D(Mat&lt;IMG_HEIGHT, IMG_WIDTH, SRC_T&gt; &amp;_src,Mat&lt;IMG_HEIGHT, IMG_WIDTH, DST_T&gt; &amp;_dst,Window&lt;K_HEIGHT,K_WIDTH,KN_T&gt;&amp;_kernel,Point_&lt;POINT_T&gt;anchor)</p>
</td>
<td><p class="first">template&lt;int BORDER_TYPE,int FILTER_WIDTH,int FILTER_HEIGHT, int SRC_T,int DST_T, int ROWS, int COLS,int NPC&gt;</p>
<p class="last">void filter2D(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat,xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; _dst_mat,short int filter[FILTER_HEIGHT*FILTER_WIDTH],unsigned char _shift)</p>
</td>
</tr>
<tr class="row-odd"><td>GaussianBlur</td>
<td><p class="first">template&lt;int KH,int KW,typename BORDERMODE,int SRC_T,int DST_T,int ROWS,int COLS&gt;</p>
<p>void GaussianBlur(Mat&lt;ROWS, COLS, SRC_T&gt;</p>
<p>&amp;_src, Mat&lt;ROWS, COLS, DST_T&gt;</p>
<p class="last">&amp;_dst,double sigmaX=0,double sigmaY=0)</p>
</td>
<td><p class="first">template&lt;int FILTER_SIZE, int BORDER_TYPE, int SRC_T, int ROWS, int COLS,int NPC = 1&gt;</p>
<p class="last">void GaussianBlur(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst, float sigma)</p>
</td>
</tr>
<tr class="row-even"><td>Harris</td>
<td><p class="first">template&lt;int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS&gt;</p>
<p>void Harris(Mat&lt;ROWS, COLS, SRC_T&gt;</p>
<p class="last">&amp;_src,Mat&lt;ROWS, COLS, DST_T&gt;&amp;_dst,KT k,int threshold</p>
</td>
<td><p class="first">template&lt;int FILTERSIZE,int BLOCKWIDTH, int NMSRADIUS,int SRC_T,int ROWS, int COLS,int NPC=1,bool USE_URAM=false&gt;</p>
<p class="last">void cornerHarris(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; dst,uint16_t threshold, uint16_t k)</p>
</td>
</tr>
<tr class="row-odd"><td>CornerHarris</td>
<td><p class="first">template&lt;int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS&gt;</p>
<p>void CornerHarris(</p>
<p class="last">Mat&lt;ROWS, COLS, SRC_T&gt;&amp;_src,Mat&lt;ROWS, COLS, DST_T&gt;&amp;_dst,KT k)</p>
</td>
<td><p class="first">template&lt;int FILTERSIZE,int BLOCKWIDTH, int NMSRADIUS,int SRC_T,int ROWS, int COLS,int NPC=1,bool USE_URAM=false&gt;</p>
<p class="last">void cornerHarris(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; dst,uint16_t threshold, uint16_t k</p>
</td>
</tr>
<tr class="row-even"><td>HoughLines2</td>
<td><p class="first">template&lt;unsigned int theta,unsigned int rho,typename AT,typename RT,int SRC_T,int ROW,int COL,unsigned int linesMax&gt;</p>
<p>void HoughLines2(Mat&lt;ROW,COL,SRC_T&gt; &amp;_src,</p>
<p class="last">Polar_&lt;AT,RT&gt; (&amp;_lines)[linesMax],unsigned int threshold)</p>
</td>
<td><p class="first">template&lt;unsigned int RHO,unsigned int THETA,int MAXLINES,int DIAG,int MINTHETA,int MAXTHETA,int SRC_T, int ROWS, int COLS,int NPC&gt;</p>
<p class="last">void HoughLines(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat,float outputrho[MAXLINES],float outputtheta[MAXLINES],short threshold,short linesmax)</p>
</td>
</tr>
<tr class="row-odd"><td>Integral</td>
<td><p class="first">template&lt;int SRC_T, int DST_T,</p>
<p>int ROWS,int COLS&gt;</p>
<p>void Integral(Mat&lt;ROWS, COLS, SRC_T&gt;&amp;_src,</p>
<p class="last">Mat&lt;ROWS+1, COLS+1, DST_T&gt;&amp;_sum )</p>
</td>
<td><p class="first">template&lt;int SRC_TYPE,int DST_TYPE, int ROWS, int COLS, int NPC&gt;</p>
<p class="last">void integral(xf::Mat&lt;SRC_TYPE, ROWS, COLS, NPC&gt; &amp; _src_mat, xf::Mat&lt;DST_TYPE, ROWS, COLS, NPC&gt; &amp; _dst_mat)</p>
</td>
</tr>
<tr class="row-even"><td>Merge</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p>void Merge(</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src0,</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src2,</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src3,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int DST_T, int ROWS, int COLS, int NPC=1&gt;</p>
<p class="last">void merge(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp;_src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp;_src2, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp;_src3, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp;_src4, xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp;_dst)</p>
</td>
</tr>
<tr class="row-odd"><td>MinMaxLoc</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, typename P_T&gt;</p>
<p>void MinMaxLoc(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>P_T* min_val,P_T* max_val,Point&amp; min_loc,</p>
<p class="last">Point&amp; max_loc)</p>
</td>
<td><p class="first">template&lt;int SRC_T,int ROWS,int COLS,int NPC=0&gt;</p>
<p class="last">void minMaxLoc(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src,int32_t *min_value, int32_t *max_value,uint16_t *_minlocx, uint16_t *_minlocy, uint16_t *_maxlocx, uint16_t *_maxlocy )</p>
</td>
</tr>
<tr class="row-even"><td>Mul</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T&gt;</p>
<p>void Mul(Mat&lt;ROWS, COLS, SRC1_T&gt;&amp; src1,</p>
<p>Mat&lt;ROWS, COLS, SRC2_T&gt;&amp; src2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int POLICY_TYPE, int SRC_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void multiply(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src1, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src2, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; dst,float scale)</p>
</td>
</tr>
<tr class="row-odd"><td>Not</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p>void Not(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void bitwise_not(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src, xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; dst)</p>
</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T, typename P_T&gt;</p>
<p>void Range(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst,</p>
<p class="last">P_T start,P_T end)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int ROWS, int COLS,int NPC=1&gt;</p>
<p class="last">void inRange(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src,unsigned char lower_thresh,unsigned char upper_thresh,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; dst)</p>
</td>
</tr>
<tr class="row-odd"><td>Resize</td>
<td><p class="first">template&lt;int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS&gt;</p>
<p>void Resize (</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt; &amp;_src,</p>
<p>Mat&lt;DROWS, DCOLS, SRC_T&gt; &amp;_dst,</p>
<p class="last">int interpolation=HLS_INTER_LINEAR )</p>
</td>
<td><p class="first">template&lt;int INTERPOLATION_TYPE, int TYPE, int SRC_ROWS, int SRC_COLS, int DST_ROWS, int DST_COLS, int NPC, int MAX_DOWN_SCALE&gt;</p>
<p class="last">void resize (xf::Mat&lt;TYPE, SRC_ROWS, SRC_COLS, NPC&gt; &amp; _src, xf::Mat&lt;TYPE, DST_ROWS, DST_COLS, NPC&gt; &amp; _dst)</p>
</td>
</tr>
<tr class="row-even"><td>sobel</td>
<td><p class="first">template&lt;int XORDER, int YORDER, int SIZE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS&gt;</p>
<p>void Sobel (Mat&lt;ROWS, COLS, SRC_T&gt;</p>
<p class="last">&amp;_src,Mat&lt;DROWS, DCOLS, DST_T&gt; &amp;_dst)</p>
</td>
<td><p class="first">template&lt;int BORDER_TYPE,int FILTER_TYPE, int SRC_T,int DST_T, int ROWS, int COLS,int NPC=1,bool USE_URAM = false&gt;</p>
<p class="last">void Sobel(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat,xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; _dst_matx,xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; _dst_maty)</p>
</td>
</tr>
<tr class="row-odd"><td>split</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p>void Split(</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst0,</p>
<p>Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst1,</p>
<p>Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst2,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst3)</p>
</td>
<td><p class="first">template&lt;int SRC_T, int DST_T, int ROWS, int COLS, int NPC=1&gt;</p>
<p class="last">void extractChannel(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat, xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; _dst_mat, uint16_t _channel)</p>
</td>
</tr>
<tr class="row-even"><td>Threshold</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T&gt;</p>
<p>void Threshold(</p>
<p>Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,</p>
<p>Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst,</p>
<p>HLS_TNAME(SRC_T) thresh,</p>
<p>HLS_TNAME(DST_T) maxval,</p>
<p class="last">int thresh_type)</p>
</td>
<td><p class="first">template&lt;int THRESHOLD_TYPE, int SRC_T, int ROWS, int COLS,int NPC=1&gt;</p>
<p class="last">void Threshold(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src_mat,xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _dst_mat,short int thresh,short int maxval )</p>
</td>
</tr>
<tr class="row-odd"><td>Scale</td>
<td><p class="first">template&lt;int ROWS, int COLS, int SRC_T, int DST_T, typename P_T&gt;</p>
<p class="last">void Scale(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src,Mat&lt;ROWS, COLS, DST_T&gt;&amp; dst, P_T scale=1.0,P_T shift=0.0)</p>
</td>
<td><p class="first">template&lt; int SRC_T,int DST_T, int ROWS, int COLS, int NPC = 1&gt;</p>
<p class="last">void scale(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; src1, xf::Mat&lt;DST_T, ROWS, COLS, NPC&gt; &amp; dst,float scale, float shift)</p>
</td>
</tr>
<tr class="row-even"><td>InitUndistortRectifyMapInverse</td>
<td><p class="first">template&lt;typename CMT, typename DT, typename ICMT, int ROWS, int COLS, int MAP1_T, int MAP2_T, int N&gt;</p>
<p>void InitUndistortRectifyMapInverse (</p>
<p class="last">Window&lt;3,3, CMT&gt; cameraMatrix,DT(&amp;distCoeffs)[N],Window&lt;3,3, ICMT&gt; ir, Mat&lt;ROWS, COLS, MAP1_T&gt; &amp;map1,Mat&lt;ROWS, COLS, MAP2_T&gt; &amp;map2,int noRotation=false)</p>
</td>
<td><p class="first">template&lt; int CM_SIZE, int DC_SIZE, int MAP_T, int ROWS, int COLS, int NPC &gt;</p>
<p>void InitUndistortRectifyMapInverse (</p>
<p>ap_fixed&lt;32,12&gt; *cameraMatrix,</p>
<p>ap_fixed&lt;32,12&gt; *distCoeffs,</p>
<p>ap_fixed&lt;32,12&gt; *ir,</p>
<p class="last">xf::Mat&lt;MAP_T, ROWS, COLS, NPC&gt; &amp;_mapx_mat,xf::Mat&lt;MAP_T, ROWS, COLS, NPC&gt; &amp;_mapy_mat,int _cm_size, int _dc_size)</p>
</td>
</tr>
<tr class="row-odd"><td>Avg, mean, AvgStddev</td>
<td><p class="first">template&lt;typename DST_T, int ROWS, int COLS, int SRC_T&gt;</p>
<p class="last">DST_T Mean(Mat&lt;ROWS, COLS, SRC_T&gt;&amp; src)</p>
</td>
<td>template&lt;int SRC_T,int ROWS, int COLS,int NPC=1&gt;void meanStdDev(xf::Mat&lt;SRC_T, ROWS, COLS, NPC&gt; &amp; _src,unsigned short* _mean,unsigned short* _stddev)</td>
</tr>
<tr class="row-even"><td>CvtColor</td>
<td><p class="first">template&lt;typename CONVERSION,int SRC_T, int DST_T,int ROWS,int COLS&gt;</p>
<p>void CvtColor(Mat&lt;ROWS, COLS, SRC_T&gt; &amp;_src,</p>
<p class="last">Mat&lt;ROWS, COLS, DST_T&gt; &amp;_dst)</p>
</td>
<td>Color Conversion</td>
</tr>
</tbody>
</table>
<p>Note: All the functions except Reduce can process N-pixels per clock
where N is power of 2.</p>
</div>
</div>
</div>
<div class="section" id="design-examples-using-vitis-vision-library">
<span id="design-example"></span><h1>Design Examples Using Vitis Vision Library<a class="headerlink" href="#design-examples-using-vitis-vision-library" title="Permalink to this headline">¶</a></h1>
<p>All the hardware functions in the library have their own respective
examples that are available in the github. This section provides details
of image processing functions and pipelines implemented using a
combination of various functions in Vitis vision. They illustrate how to
best implement various functionalities using the capabilities of both
the processor and the programmable logic. These examples also illustrate
different ways to implement complex dataflow paths. The following
examples are described in this section:</p>
<ul class="simple">
<li><a class="reference external" href="#interactive-pyramidal">Iterative Pyramidal Dense Optical Flow</a></li>
<li><a class="reference external" href="#corner-tracking">Corner Tracking Using Optical Flow</a></li>
<li><a class="reference external" href="#color-detection">Color Detection</a></li>
<li><a class="reference external" href="#difference-gaussian-filter">Difference of Gaussian Filter</a></li>
<li><a class="reference external" href="#stereo-vision">Stereo Vision Pipeline</a></li>
<li><a class="reference external" href="#x-mlpipeline">X + ML Pipeline</a></li>
<li><a class="reference external" href="#letter-box">Letterbox</a></li>
<li><a class="reference external" href="#isp">Image Sensor Processing pipeline</a></li>
</ul>
<div class="section" id="interative-pyramidal">
<span id="id7"></span><h2>Iterative Pyramidal Dense Optical Flow<a class="headerlink" href="#interative-pyramidal" title="Permalink to this headline">¶</a></h2>
<p>The Dense Pyramidal Optical Flow example uses the <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> and
<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> hardware functions from the Vitis vision
library, to create an image pyramid, iterate over it and compute the
Optical Flow between two input images. The example uses <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> function to compute the image pyramids
of the two input images. The two image pyramids are
processed by <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>
function, starting from the smallest image size going up to the largest
image size. The output flow vectors of each iteration are fed back to
the hardware kernel as input to the hardware function. The output of the
last iteration on the largest image size is treated as the output of the
dense pyramidal optical flow example.</p>
<div class="image figure" id="jcr1510602888334-image-jh4-sq2-bcb">
<img alt="" src="_images/bui1554997287170.png" />
</div>
<p>The Iterative Pyramidal Dense Optical Flow is computed in a nested for
loop which runs for iterations*pyramid levels number of iterations. The
main loop starts from the smallest image size and iterates up to the
largest image size. Before the loop iterates in one pyramid level, it
sets the current pyramid level’s height and width, in curr_height and
current_width variables. In the nested loop, the next_height variable is
set to the previous image height if scaling up is necessary, that is, in
the first iterations. As divisions are costly and one time divisions can
be avoided in hardware, the scale factor is computed in the host and
passed as an argument to the hardware kernel. After each pyramid level,
in the first iteration, the scale-up flag is set to let the hardware
function know that the input flow vectors need to be scaled up to the
next higher image size. Scaling up is done using bilinear interpolation
in the hardware kernel.</p>
<p>After all the input data is prepared, and the flags are set, the host
processor calls the hardware function. Please note that the host
function swaps the flow vector inputs and outputs to the hardware
function to iteratively solve the optimization problem.</p>
</div>
<div class="section" id="corner-tracking">
<span id="id8"></span><h2>Corner Tracking Using Optical Flow<a class="headerlink" href="#corner-tracking" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates how to detect and track the characteristic
feature points in a set of successive frames of video. A Harris corner
detector is used as the feature detector, and a modified version of
Lucas Kanade optical flow is used for tracking. The core part of the
algorithm takes in current and next frame as the inputs and outputs the
list of tracked corners. The current image is the first frame in the
set, then corner detection is performed to detect the features to track.
The number of frames in which the points need to be tracked is also
provided as the input.</p>
<p>Corner tracking example uses five hardware functions from the Vitis vision
library <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::</span> <span class="pre">cornersImgToList</span></code>,
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code>, and <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>.</p>
<div class="image figure" id="ypx1510602888667-image-dmv-5cv-hdb">
<img alt="" src="_images/tpr1554997250097.png" />
</div>
<p>The function, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, has been added to ensure
that the dense flow vectors from the output of
the<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> function are sparsely picked and stored
in a new memory location as a sparse array. This was done to ensure that
the next function in the pipeline would not have to surf through the
memory by random accesses. The function takes corners from Harris corner
detector and dense optical flow vectors from the dense pyramidal optical
flow function and outputs the updated corner locations, tracking the
input corners using the dense flow vectors, thereby imitating the sparse
optical flow behavior. This hardware function runs at 300 MHz for 10,000
corners on a 720p image, adding very minimal latency to the pipeline.</p>
<div class="section" id="cornerupdate">
<h3>cornerUpdate()<a class="headerlink" href="#cornerupdate" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornerUpdate</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">list_fix</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="nb">list</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">nCorners</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">flow_vectors</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">harris_flag</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id36">
<caption><span class="caption-text">Table: CornerUpdate Function Parameter Descriptions</span><a class="headerlink" href="#id36" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Paramete
r</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAXCORNE
RSNO</td>
<td>Maximum number of corners that the function needs to work
on</td>
</tr>
<tr class="row-odd"><td>TYPE</td>
<td>Input Pixel Type. Only 8-bit, unsigned, 1 channel is
supported (XF_8UC1)</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input and output image (Must be
multiple of 8)</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input and output image (Must be multiple
of 8)</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed per cycle. This function
supports only XF_NPPC1 or 1-pixel per cycle operations.</td>
</tr>
<tr class="row-odd"><td>list_fix</td>
<td>A list of packed fixed point coordinates of the corner
locations in 16, 5 (16 integer bits and 5 fractional
bits) format. Bits from 20 to 0 represent the column
number, while the bits 41 to 21 represent the row number.
The rest of the bits are used for flag, this flag is set
when the tracked corner is valid.</td>
</tr>
<tr class="row-even"><td>list</td>
<td>A list of packed positive short integer coordinates of
the corner locations in unsigned short format. Bits from
15 to 0 represent the column number, while the bits 31 to
16 represent the row number. This list is same as the
list output by Harris Corner Detector.</td>
</tr>
<tr class="row-odd"><td>nCorners</td>
<td>Number of corners to track</td>
</tr>
<tr class="row-even"><td>flow_vec
tors</td>
<td>Packed flow vectors as in xf::cv::DensePyrOpticalFlow
function</td>
</tr>
<tr class="row-odd"><td>harris_f
lag</td>
<td><p class="first">If set to 1, the function takes input corners from list.</p>
<p class="last">if set to 0, the function takes input corners from
list_fix.</p>
</td>
</tr>
</tbody>
</table>
<p>The example codeworks on an input video which is read and processed
using the Vitis vision library.</p>
</div>
<div class="section" id="cornersimgtolist">
<h3>cornersImgToList()<a class="headerlink" href="#cornersimgtolist" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornersImgToList</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_src</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">[</span><span class="n">MAXCORNERSNO</span><span class="p">],</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="n">ncorners</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the function parameters.</p>
<table border="1" class="docutils" id="id37">
<caption><span class="caption-text">Table: CornerImgToList Function Parameter Descriptions</span><a class="headerlink" href="#id37" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Paramete
r</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>_src</td>
<td>The output image of harris corner detector. The size of
this xf::cv::Mat object is the size of the input image to
Harris corner detector. The value of each pixel is 255 if
a corner is present in the location, 0 otherwise.</td>
</tr>
<tr class="row-odd"><td>list</td>
<td>A 32 bit memory allocated, the size of MAXCORNERS, to
store the corners detected by Harris Detector</td>
</tr>
<tr class="row-even"><td>ncorners</td>
<td>Total number of corners detected by Harris, that is, the
number of corners in the list</td>
</tr>
</tbody>
</table>
<div class="section" id="image-processing">
<h4>Image Processing<a class="headerlink" href="#image-processing" title="Permalink to this headline">¶</a></h4>
<p>The following steps demonstrate the Image Processing procedure in the
hardware pipeline</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> is called to start processing the first input
image</li>
<li>The output of<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code> is fed to<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code>. This function takes in an
image with corners (marked as 255 and 0 elsewhere), and converts them
to a list of corners.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> creates the two image pyramids and
Dense Optical Flow is computed using the two image pyramids as
described in the Iterative Pyramidal Dense Optical Flow example.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> is called with the two image pyramids as
inputs.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function is called to track the corner locations
in the second image. If harris_flag is enabled, the <code class="docutils literal notranslate"><span class="pre">cornerUpdate</span></code>
tracks corners from the output of the list, else it tracks the
previously tracked corners.</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">HarrisImg()</span></code> function takes a flag called
harris_flag which is set during the first frame or when the corners need
to be redetected. The <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function outputs the updated
corners to the same memory location as the output corners list of
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerImgToList</span></code>. This means that when harris_flag is unset, the
corners input to the <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> are the corners tracked in the
previous cycle, that is, the corners in the first frame of the current
input frames.</p>
<p>After the Dense Optical Flow is computed, if harris_flag is set, the
number of corners that <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> has detected and
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code> has updated is copied to num_corners variable
. The other being the tracked corners list, listfixed. If
harris_flag is set, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> tracks the corners in ‘list’
memory location, otherwise it tracks the corners in ‘listfixed’ memory
location.</p>
</div>
</div>
</div>
<div class="section" id="id9">
<span id="id10"></span><h2>Color Detection<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>The Color Detection algorithm is basically used for color object
tracking and object detection, based on the color of the object. The
color based methods are very useful for object detection and
segmentation, when the object and the background have a significant
difference in color.</p>
<p>The Color Detection example uses four hardware functions from the
Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::BGR2HSV</li>
<li>xf::cv::colorthresholding</li>
<li>xf::cv::erode</li>
<li>xf::cv::dilate</li>
</ul>
<p>In the Color Detection example, the color space of the original BGR
image is converted into an HSV color space. Because HSV color space is
the most suitable color space for color based image segmentation. Later,
based on the H (hue), S (saturation) and V (value) values, apply the
thresholding operation on the HSV image and return either 255 or 0.
After thresholding the image, apply erode (morphological opening) and
dilate (morphological opening) functions to reduce unnecessary white
patches (noise) in the image. Here, the example uses two hardware
instances of erode and dilate functions. The erode followed by dilate
and once again applying dilate followed by erode.</p>
<div class="image figure" id="dyn1510602889272-image-dzq-ys2-bcb">
<img alt="" src="_images/ntl1554997353703.png" />
</div>
<p>The following example demonstrates the Color Detection algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">color_detect</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">low_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">high_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">process_shape</span><span class="p">,</span>
              <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=low_thresh    offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=low_thresh</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=high_thresh   offset=slave  bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=high_thresh</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=process_shape offset=slave  bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=process_shape</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem4</span>

<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">rgb2hsv</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgHelper1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgHelper2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgHelper3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgHelper4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">shape</span> <span class="n">data</span><span class="p">:</span>
<span class="n">unsigned</span> <span class="n">char</span> <span class="n">_kernel</span><span class="p">[</span><span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">#pragma HLS PIPELINE</span>
    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
    <span class="n">_kernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_shape</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">#pragma HLS DATAFLOW</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
<span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="p">,</span> <span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Convert</span> <span class="n">RGBA</span> <span class="n">to</span> <span class="n">HSV</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">bgr2hsv</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">rgb2hsv</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Do</span> <span class="n">the</span> <span class="n">color</span> <span class="n">thresholding</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">colorthresholding</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">MAXCOLORS</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rgb2hsv</span><span class="p">,</span> <span class="n">imgHelper1</span><span class="p">,</span> <span class="n">low_thresh</span><span class="p">,</span>
                                                                             <span class="n">high_thresh</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Use</span> <span class="n">erode</span> <span class="ow">and</span> <span class="n">dilate</span> <span class="n">to</span> <span class="n">fully</span> <span class="n">mark</span> <span class="n">color</span> <span class="n">areas</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
              <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper1</span><span class="p">,</span> <span class="n">imgHelper2</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
               <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper2</span><span class="p">,</span> <span class="n">imgHelper3</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
               <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper3</span><span class="p">,</span> <span class="n">imgHelper4</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
              <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Convert</span> <span class="n">_dst</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

<span class="k">return</span><span class="p">;</span>

    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the source image is passed to the <code class="docutils literal notranslate"><span class="pre">xf::cv::BGR2HSV</span></code>
function, the output of that function is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::colorthresholding</span></code> module, the thresholded image is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::erode</span></code> function and, the <code class="docutils literal notranslate"><span class="pre">xf::cv::dilate</span></code> functions and the final
output image are returned.</p>
</div>
<div class="section" id="difference-gaussian-filter">
<span id="id11"></span><h2>Difference of Gaussian Filter<a class="headerlink" href="#difference-gaussian-filter" title="Permalink to this headline">¶</a></h2>
<p>The Difference of Gaussian Filter example uses four hardware functions
from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::GaussianBlur</li>
<li>xf::cv::duplicateMat</li>
<li>xf::cv::subtract</li>
</ul>
<p>The Difference of Gaussian Filter function can be implemented by
applying Gaussian Filter on the original source image, and that Gaussian
blurred image is duplicated as two images. The Gaussian blur function is
applied to one of the duplicated images, whereas the other one is stored
as it is. Later, perform the Subtraction function on, two times Gaussian
applied image and one of the duplicated image.</p>
<div class="image figure" id="fmq1510602889620-image-lgr-1xf-bcb">
<img alt="" src="_images/crx1554997276344.png" />
</div>
<p>The following example demonstrates the Difference of Gaussian Filter
example.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">gaussiandiference</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span> <span class="nb">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=sigma</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>


<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span> <span class="n">imgin3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="c1">#pragma HLS DATAFLOW</span>

<span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Run</span> <span class="n">xfOpenCV</span> <span class="n">kernel</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">imgin1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">duplicateMat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin1</span><span class="p">,</span> <span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin3</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">subtract</span><span class="o">&lt;</span><span class="n">XF_CONVERT_POLICY_SATURATE</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin3</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Convert</span> <span class="n">output</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

<span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the Gaussain Blur function is applied for source
image imginput, and resultant image imgin1 is passed to
xf::cv::duplicateMat. The imgin2 and imgin3 are the duplicate images of
Gaussian applied image. Again gaussian blur is applied to imgin2 and the
result is stored in imgin4. Now, perform the subtraction between imgin4
and imgin3, but here imgin3 has to wait up to at least one pixel of
imgin4 generation. Finally the subtraction performed on imgin3 and imgin4.</p>
</div>
<div class="section" id="stereo-vision">
<span id="id12"></span><h2>Stereo Vision Pipeline<a class="headerlink" href="#stereo-vision" title="Permalink to this headline">¶</a></h2>
<p>Disparity map generation is one of the first steps in creating a three
dimensional map of the environment. The Vitis vision library has components
to build an image processing pipeline to compute a disparity map given
the camera parameters and inputs from a stereo camera setup.</p>
<p>The two main components involved in the pipeline are stereo
rectification and disparity estimation using local block matching
method. While disparity estimation using local block matching is a
discrete component in Vitis vision, rectification block can be constructed
using <code class="docutils literal notranslate"><span class="pre">xf::cv::InitUndistortRectifyMapInverse()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::Remap()</span></code>. The
dataflow pipeline is shown below. The camera parameters are an
additional input to the pipeline.</p>
<div class="image figure">
<a class="reference internal image-reference" href="_images/qlb1554997048260.png"><img alt="" src="_images/qlb1554997048260.png" style="width: 560px; height: 240px;" /></a>
</div>
<p>The following code is for the pipeline.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">stereopipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_L</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_R</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_disp</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_r</span><span class="p">,</span>
                      <span class="nb">int</span><span class="o">*</span> <span class="n">bm_state_arr</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi     port=img_L  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_R  offset=slave bundle=gmem5</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_disp  offset=slave bundle=gmem6</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_l  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_r  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=bm_state_arr  offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>

<span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span> <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">#pragma HLS PIPELINE II=1</span>
    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
    <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">#pragma HLS PIPELINE II=1</span>
    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xFSBMState</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="o">&gt;</span> <span class="n">bm_state</span><span class="p">;</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterType</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterCap</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">SADWindowSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">minDisparity</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">numberOfDisparities</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">textureThreshold</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">uniquenessRatio</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">ndisp_unit</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">sweepFactor</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="n">bm_state</span><span class="o">.</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="nb">int</span> <span class="n">_cm_size</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">_dc_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mat_L</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mat_R</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mat_disp</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mapxLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mapyLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mapxRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">mapyRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">leftRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span> <span class="n">rightRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>


<span class="c1">#pragma HLS DATAFLOW</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_L</span><span class="p">,</span> <span class="n">mat_L</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_R</span><span class="p">,</span> <span class="n">mat_R</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                       <span class="n">XF_NPPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_l_fix</span><span class="p">,</span> <span class="n">distC_l_fix</span><span class="p">,</span> <span class="n">irA_l_fix</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">,</span>
                                                 <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
              <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_L</span><span class="p">,</span> <span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                       <span class="n">XF_NPPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_r_fix</span><span class="p">,</span> <span class="n">distC_r_fix</span><span class="p">,</span> <span class="n">irA_r_fix</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">,</span>
                                                 <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
              <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_R</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">StereoBM</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                 <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mat_disp</span><span class="p">,</span> <span class="n">bm_state</span><span class="p">);</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_disp</span><span class="p">,</span> <span class="n">img_disp</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x-mlpipeline">
<span id="id13"></span><h2>X + ML Pipeline<a class="headerlink" href="#x-mlpipeline" title="Permalink to this headline">¶</a></h2>
<p>This example shows how various xfOpenCV funtions can be used to accelerate preprocessing of input images before feeding them to a Deep Neural Network (DNN) accelerator.</p>
<p>This specific application shows how pre-processing for Googlenet_v1 can be accelerated which involves resizing the input image to 224 x 224 size followed by mean subtraction. The two main
functions from Vitis vision library which are used to build this pipeline are <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> which operate in dataflow.</p>
<p><a class="image reference internal" href="_images/gnet_pp.png"><img alt="pp_image" class="image" src="_images/gnet_pp.png" style="width: 500px;" /></a></p>
<p>The following code shows the top level wrapper containing the <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> calls.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">pp_pipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span> <span class="nb">float</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">T_CHANNELS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">th1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">th2</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span><span class="n">HLS</span> <span class="n">Interface</span> <span class="n">pragmas</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=params  offset=slave bundle=gmem3</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th1     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th2     bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>

<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC3</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>   <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>


<span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>


    <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">resizeStrmout</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">srcMat_cols_align_npc</span> <span class="o">=</span> <span class="p">((</span><span class="n">out_mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="p">(</span><span class="n">NPC_T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">accel_utils</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">xfMat2hlsStrm</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="p">(</span><span class="n">NEWWIDTH</span><span class="o">*</span><span class="n">NEWHEIGHT</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">srcMat_cols_align_npc</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">preProcess</span> <span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">T_CHANNELS</span><span class="p">,</span> <span class="n">CPW</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_TEST</span><span class="p">,</span> <span class="n">PACK_MODE</span><span class="p">,</span> <span class="n">X_WIDTH</span><span class="p">,</span> <span class="n">ALPHA_WIDTH</span><span class="p">,</span> <span class="n">BETA_WIDTH</span><span class="p">,</span> <span class="n">GAMMA_WIDTH</span><span class="p">,</span> <span class="n">OUT_WIDTH</span><span class="p">,</span> <span class="n">X_IBITS</span><span class="p">,</span> <span class="n">ALPHA_IBITS</span><span class="p">,</span> <span class="n">BETA_IBITS</span><span class="p">,</span> <span class="n">GAMMA_IBITS</span><span class="p">,</span> <span class="n">OUT_IBITS</span><span class="p">,</span> <span class="n">SIGNED_IN</span><span class="p">,</span> <span class="n">OPMODE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">img_out</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>This piepeline is integrated with Deep learning Processign Unit(DPU) as part of <a class="reference external" href="https://github.com/Xilinx/Vitis-AI/tree/master/Vitis-AI-Library">Vitis-AI-Library</a>  and achieved
11 % speed up compared to software pre-procesing.</p>
<ul class="simple">
<li>Overall Performance (Images/sec):</li>
<li>with software pre-processing : 125 images/sec</li>
<li>with hardware accelerated pre-processing : 140 images/sec</li>
</ul>
</div>
<div class="section" id="letter-box">
<span id="id14"></span><h2>Letterbox<a class="headerlink" href="#letter-box" title="Permalink to this headline">¶</a></h2>
<p>The Letterbox algorithm is used for scaling input image to desired output size while preserving aspect ratio of original image. If required, zeroes are padded for preserving the aspect ratio post resize.</p>
<p>An application of letterbox is in the pre-processing block of machine learning pipelines used in image processing.</p>
<p><a class="image reference internal" href="./images/letterbox.png"><img alt="pp_image1" class="image" src="./images/letterbox.png" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the Letterbox algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">letterbox_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">insert_pad_value</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
                    <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=insert_pad_value</span>
                    <span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>


                    <span class="o">//</span> <span class="n">Compute</span> <span class="n">Resize</span> <span class="n">output</span> <span class="n">image</span> <span class="n">size</span> <span class="k">for</span> <span class="n">Letterbox</span>
                    <span class="nb">float</span> <span class="n">scale_height</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">scale_width</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">;</span>
                    <span class="nb">int</span> <span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">scale_width</span><span class="o">&lt;</span><span class="n">scale_height</span><span class="p">){</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="n">cols_out</span><span class="p">;</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">rows_in</span><span class="o">*</span><span class="n">cols_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span><span class="p">{</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">cols_in</span><span class="o">*</span><span class="n">rows_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">);</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="n">rows_out</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">out_mat_resize</span><span class="p">(</span><span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>

                    <span class="c1">#pragma HLS DATAFLOW</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">insertBorder</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat_resize</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">,</span> <span class="n">insert_pad_value</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span><span class="o">//</span> <span class="n">end</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>The Letterbox example uses two hardware functions from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::resize</li>
<li>xf::cv::insertBorder</li>
</ul>
<p>In the given example, the source image is passed to the xf::cv::resize function.
The output of that function is passed to the xf::cv::insertBorder module and the final output image are returned.</p>
<p class="rubric">Insert Border API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span>
    <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">NPC</span>
    <span class="o">&gt;</span>
<span class="n">void</span> <span class="n">insertBorder</span> <span class="p">(</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">SRC_ROWS</span><span class="p">,</span> <span class="n">SRC_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">_src</span><span class="p">,</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">DST_ROWS</span><span class="p">,</span> <span class="n">DST_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="o">&gt;&amp;</span> <span class="n">_dst</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">insert_pad_val</span>
    <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>TYPE</td>
<td>input and ouput type</td>
</tr>
<tr class="row-even"><td>SRC_ROWS</td>
<td>rows of the input image</td>
</tr>
<tr class="row-odd"><td>SRC_COLS</td>
<td>cols of the input image</td>
</tr>
<tr class="row-even"><td>DST_ROWS</td>
<td>rows of the output image</td>
</tr>
<tr class="row-odd"><td>DST_COLS</td>
<td>cols of the output image</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>number of pixels processed per cycle</td>
</tr>
<tr class="row-odd"><td>_src</td>
<td>input image</td>
</tr>
<tr class="row-even"><td>_dst</td>
<td>output image</td>
</tr>
<tr class="row-odd"><td>insert_pad_val</td>
<td>insert pad value</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="isp">
<span id="id15"></span><h2>Image Sensor Processing pipeline<a class="headerlink" href="#isp" title="Permalink to this headline">¶</a></h2>
<p>Image Sensor Processing (ISP) is a pipeline of image processing functions processing the raw image from the sensor.</p>
<p>Current ISP includes following 4 blocks:</p>
<ul class="simple">
<li>BPC (Bad pixel correction) : An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
</ul>
<p>Current design example demonstrates how to use ISP functions in a pipeline. User can include other modules (like gamma correction, color conversion, resize etc) based on their need.</p>
<p><a class="image reference internal" href="./images/isp.png"><img alt="pp_image_es" class="image" src="./images/isp.png" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the ISP pipeline.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp, ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out, int height, int width) {

#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
#pragma HLS INTERFACE s_axilite port=height
#pragma HLS INTERFACE s_axilite port=width
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS ARRAY_PARTITION variable=hist0 complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1 complete dim=1

if (!flag) {
        ISPpipeline(img_inp, img_out, height, width, hist0, hist1);
        flag = 1;
} else {
        ISPpipeline(img_inp, img_out, height, width, hist1, hist0);
        flag = 0;
}
}
void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                 int height,
                                 int width,
                                 uint32_t hist0[3][256],
                                 uint32_t hist1[3][256]) {
#pragma HLS INLINE OFF
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; imgInput1(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; bpc_out(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; gain_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; demosaic_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; impop(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; _dst(height, width);

#pragma HLS stream variable=bpc_out.data dim=1 depth=2
#pragma HLS stream variable=gain_out.data dim=1 depth=2
#pragma HLS stream variable=demosaic_out.data dim=1 depth=2
#pragma HLS stream variable=imgInput1.data dim=1 depth=2
#pragma HLS stream variable=impop.data dim=1 depth=2
#pragma HLS stream variable=_dst.data dim=1 depth=2

#pragma HLS DATAFLOW


        float inputMin = 0.0f;
        float inputMax = 255.0f;
        float outputMin = 0.0f;
        float outputMax = 255.0f;
        float p = 2.0f;

        xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(img_inp, imgInput1);
        xf::cv::badpixelcorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, 0&gt;(imgInput1, bpc_out);
        xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(bpc_out, gain_out);
        xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0&gt;(gain_out, demosaic_out);
        xf::cv::AWBhistogram&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE&gt;(
                demosaic_out, impop, hist0, p, inputMin, inputMax, outputMin, outputMax);
        xf::cv::AWBNormalization&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE&gt;(impop, _dst, hist1, p, inputMin,
                                                                                                                                                                                inputMax, outputMin, outputMax);
        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(_dst, img_out);
}
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->

</footer>

        </div>
      </div>
	  
	  
	  <!-- Sphinx Page Footer block -->
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api-reference.html" class="btn btn-neutral float-right" title="Overview" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Vitis Vision Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p class="footerinfo">
      <span class="lastupdated">
        Last updated on June 05, 2020.
      </span>

    </p>
  </div>	  
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
  

  
  <!--  Xilinx template footer block -->
							</div>
						</div>
					</div>
				</div>
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="footer parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
								<noindex>
									<footer>
										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">
													<div class="row">
														<div class="footerSocial parbase">
															<div class="col-md-push-6 col-lg-push-6 col-md-6 col-lg-6">
																<ul class="list-inline pull-right social-menu">
																	<li>
																		<a href="https://www.linkedin.com/company/xilinx">
																		<span class="linkedin icon"></span>
																		<span class="sr-only">Connect on LinkedIn</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.twitter.com/XilinxInc">
																		<span class="twitter icon"></span>
																		<span class="sr-only">Follow us on Twitter</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.facebook.com/XilinxInc">
																		<span class="facebook icon"></span>
																		<span class="sr-only">Connect on Facebook</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.youtube.com/XilinxInc">
																		<span class="youtube icon"></span>
																		<span class="sr-only">Watch us on YouTube</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.xilinx.com/registration/subscriber-signup.html">
																		<span class="newsletter icon"></span>
																		<span class="sr-only">Subscribe to Newsletter</span>
																		</a>
																	</li>
																</ul>
															</div>
														</div>
														<div class="col-md-pull-6 col-lg-pull-6 col-md-6 col-lg-6">
															<span class="copyright">
                                  
                                  &copy; 2020, Xilinx
                              </span>
															<ul class="list-inline sub-menu">
																<li>
																	<a href="https://www.xilinx.com/about/privacy-policy.html">Privacy</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/legal.html">Legal</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/contact.html">Contact</a>
																</li>
															</ul>
														</div>
													</div>
												</div>
											</div>
										</div>
									</footer>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="quicklinks parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<noindex>
						<span class="quickLinks">
							<ul>
								<li>
									<a href="#top" class="btn backToTop">
									<span class="fas fa-angle-up" aria-hidden="true"></span>
									</a>
								</li>
							</ul>
						</span>
					</noindex>
				</div>
			</div>
		</div>
		<script>window.CQ = window.CQ || {}</script>
		<script src="https://static.cloud.coveo.com/searchui/v2.4382/js/CoveoJsSearch.Lazy.min.js"></script>
		<script>
			var underscoreSetup = function () {
			  _.templateSettings.interpolate = /\{\{=([^-][\S\s]+?)\}\}/g;
			  _.templateSettings.evaluate = /\{\{([^-=][\S\s]+?)\}\}/g;
			  _.templateSettings.escape = /\{\{-([^=][\S\s]+?)\}\}/g;
			}
			
			underscoreSetup();
		</script>
	</body>
</html>