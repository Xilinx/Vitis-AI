From c1866d716344f768d264a7d0778fc2d654ceb792 Mon Sep 17 00:00:00 2001
From: Thomas Nizan <tnizan@witekio.com>
Date: Thu, 18 Feb 2021 00:00:50 +0000
Subject: [PATCH 07/14] media: i2c: Add MARS driver

The MARS module is a GMSL camera supporting 1920x1080 and 1280x720
resolution images, developed by ON Semiconductor and based on an AR0231
sensor and a Maxim MAX96705 GMSL serializer.

The GMSL link carries power, control (I2C) and video data over a single
coax cable.
---
 drivers/media/i2c/Kconfig    |  17 +
 drivers/media/i2c/Makefile   |   2 +
 drivers/media/i2c/mars.c     | 835 +++++++++++++++++++++++++++++++++++++++++++
 drivers/media/i2c/mars.h     | 395 ++++++++++++++++++++
 drivers/media/i2c/max96705.c | 469 ++++++++++++++++++++++++
 drivers/media/i2c/max96705.h | 210 +++++++++++
 6 files changed, 1928 insertions(+)
 create mode 100644 drivers/media/i2c/mars.c
 create mode 100644 drivers/media/i2c/mars.h
 create mode 100644 drivers/media/i2c/max96705.c
 create mode 100644 drivers/media/i2c/max96705.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 837fee5..9cd0e7e 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -1195,6 +1195,23 @@ config VIDEO_RDACM20
 	  This camera should be used in conjunction with a GMSL
 	  deserialiser such as the MAX9286.
 
+config VIDEO_MAX96705_LIB
+	tristate
+
+config VIDEO_MARS
+	tristate "ON Semiconductor MARS camera support"
+	depends on I2C
+	select V4L2_FWNODE
+	select VIDEO_V4L2_SUBDEV_API
+	select MEDIA_CONTROLLER
+	select VIDEO_MAX96705_LIB
+	help
+	  This driver supports the ON Semiconductor MARS GMSL camera module, used in
+	  ADAS systems.
+
+	  This camera module should be used in conjunction with a GMSL
+	  deserialiser such as the MAX9286.
+
 config VIDEO_RJ54N1
 	tristate "Sharp RJ54N1CB0C sensor support"
 	depends on I2C && VIDEO_V4L2
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 6742ff8..b0d89a5 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -123,6 +123,8 @@ obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
 obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
 rdacm20-camera_module-objs	:= rdacm20.o max9271.o
 obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20-camera_module.o
+obj-$(CONFIG_VIDEO_MAX96705_LIB) += max96705.o
+obj-$(CONFIG_VIDEO_MARS) += mars.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
 
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
diff --git a/drivers/media/i2c/mars.c b/drivers/media/i2c/mars.c
new file mode 100644
index 0000000..a969199
--- /dev/null
+++ b/drivers/media/i2c/mars.c
@@ -0,0 +1,835 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * MARS GMSL Camera Driver
+ */
+
+#define DEBUG
+/*
+ * The camera is made of an ON Semiconductor AR0231 sensor connected to a Maxim
+ * MAX96705 GMSL serializer.
+ */
+
+#include "mars.h"
+
+#include <linux/delay.h>
+#include <linux/fwnode.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "max96705.h"
+
+/*
+ * As the drivers supports a single MEDIA_BUS_FMT_SGRBG12_1X12 format we
+ * can harcode the pixel rate.
+ */
+#define AR0231_PIXEL_RATE		(75000000)
+
+#define MARS_MODE_REG_TABLE_SIZE	15
+
+/* There's no standard V4L2_CID_GREEN_BALANCE defined in the
+ * linux kernel. Let's borrow V4L2_CID_CHROMA_GAIN on green
+ * balance adjustment
+ */
+#define V4L2_CID_GREEN_BALANCE		V4L2_CID_CHROMA_GAIN
+
+struct mars_device {
+	struct device			*dev;
+	struct max96705_device		serializer;
+	struct i2c_client		*sensor;
+	struct v4l2_subdev		sd;
+	struct media_pad		pad;
+	struct v4l2_ctrl_handler	ctrls;
+	u32				addrs[2];
+	struct regmap			*sensor_regmap;
+	struct v4l2_mbus_framefmt	fmt;
+	/* Protects fmt structure */
+	struct mutex			mutex;
+};
+
+static const struct ar0231_reg mode_1280x720[] = {
+	{ 0x301A, 0x10D8 }, // RESET_REGISTER
+	{ 0x3004, 0x0140 }, // X_ADDR_START = 320
+	{ 0x3008, 0x063F }, // X_ADDR_END = 1599 ... 1599-320 = 1279
+	{ 0x3002, 0x00F0 }, // Y_ADDR_START = 240
+	{ 0x3006, 0x03BF }, // Y_ADDR_END = 959 ... 959-240 =719
+	{ 0x3032, 0x0000 }, // SCALING_MODE
+	{ 0x3400, 0x0010 }, // RESERVED_MFR_3400
+	{ 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+	{ 0x3402, 0x0A10 }, // X_OUTPUT_CONTROL
+	{ 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+	{ 0x3404, 0x05B0 }, // Y_OUTPUT_CONTROL
+	{ 0x300C, 0x05DC },  // LINE_LENGTH_PCK_ = 1500 (1280+220 or 1280+17%)
+	{ 0x300A, 0x0335 },  // FRAME_LENGTH_LINES_ = 821
+	{ 0x3042, 0x0000 },  // EXTRA_DELAY = 0
+						// TOTAL CYCLES = 1500*821 + 0
+						// = 1,315,000
+	{ 0x301A, 0x19DC }, // RESET_REGISTER
+};
+
+static const struct ar0231_reg mode_1920x1080[] = {
+	{ 0x301A, 0x10D8 }, // RESET_REGISTER
+	{ 0x3004, 0x0000 }, // X_ADDR_START = 0
+	{ 0x3008, 0x077F }, // X_ADDR_END = 1919
+	{ 0x3002, 0x003C }, // Y_ADDR_START = 60
+	{ 0x3006, 0x0473 }, // Y_ADDR_END = 1139 ... 1139-60 // =1079
+	{ 0x3032, 0x0000 }, // SCALING_MODE
+	{ 0x3400, 0x0010 }, // RESERVED_MFR_3400
+	{ 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+	{ 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+	{ 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+	{ 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+	{ 0x300C, 0x080E },  // LINE_LENGTH_PCK_ = 2062
+	{ 0x300A, 0x0484 },  // FRAME_LENGTH_LINES_ = 1156
+	{ 0x3042, 0x0000 },  // EXTRA_DELAY = 0
+						// TOTAL CYCLES = 2062*1156 + 0
+						// = 2,383,672
+	{ 0x301A, 0x19DC }, // RESET_REGISTER
+};
+
+static const struct mars_mode {
+	u32 width;
+	u32 height;
+	const struct ar0231_reg *reg_table;
+} mars_modes[] = {
+	{
+		.width = 1920,
+		.height = 1080,
+		.reg_table = mode_1920x1080,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.reg_table = mode_1280x720,
+	},
+};
+
+static inline struct mars_device *sd_to_mars(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mars_device, sd);
+}
+
+static inline struct mars_device *i2c_to_mars(struct i2c_client *client)
+{
+	return sd_to_mars(i2c_get_clientdata(client));
+}
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sensor_read(struct mars_device *dev, unsigned int reg,
+		       unsigned int *val)
+{
+	int ret;
+
+	ret = regmap_read(dev->sensor_regmap, reg, val);
+	return ret;
+}
+
+static int sensor_write(struct mars_device *dev, u16 reg, u16 val)
+{
+	return regmap_write(dev->sensor_regmap, reg, val);
+}
+
+static int sensor_set_regs(struct mars_device *dev,
+			   const struct ar0231_reg *regs,
+			   unsigned int nr_regs)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < nr_regs; i++) {
+		ret = sensor_write(dev, regs[i].reg, regs[i].val);
+		if (ret) {
+			dev_err(dev->dev,
+				"%s: register %u (0x%04x) write failed (%d)\n",
+				__func__, i, regs[i].reg, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------
+ * Register Configuration
+ */
+
+#define AR0231_COARSE_INTEGRATION_TIME_		0x3012
+#define AR0231_BLUE_GAIN			0x3058
+#define AR0231_GREEN1_GAIN			0x3056
+#define AR0231_GREEN2_GAIN			0x305C
+#define AR0231_RED_GAIN				0x305A
+#define AR0231_ANALOG_GAIN			0x3366
+#define AR0231_DIGITAL_GAIN			0x3308
+#define AR0231_READ_MODE			0x3040
+#define AR0231_READ_MODE_HORIZ_MIRROR		BIT(14)
+#define AR0231_READ_MODE_VERT_FLIP		BIT(15)
+#define AR0231_TEST_PATTERN_MODE_		0x3070
+
+static const struct ar0231_reg ar0231_test_pattern_none[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0000 }, // Test Pattern = normal
+	{ 0x3072, 0x0000 }, // Red    = 0x0000
+	{ 0x3074, 0x0000 }, // Green1 = 0x0000
+	{ 0x3076, 0x0000 }, // Blue   = 0x0000
+	{ 0x3078, 0x0000 }, // Green2 = 0x0000
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_red[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0001 }, // Test Pattern = solid color
+	{ 0x3072, 0x0FFF }, // Red    = 0x0FFF
+	{ 0x3074, 0x0000 }, // Green1 = 0x0000
+	{ 0x3076, 0x0000 }, // Blue   = 0x0000
+	{ 0x3078, 0x0000 }, // Green2 = 0x0000
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_green[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0001 }, // Test Pattern = solid color
+	{ 0x3072, 0x0000 }, // Red    = 0x0000
+	{ 0x3074, 0x0FFF }, // Green1 = 0x0FFF
+	{ 0x3076, 0x0000 }, // Blue   = 0x0000
+	{ 0x3078, 0x0FFF }, // Green2 = 0x0FFF
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_blue[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0001 }, // Test Pattern = solid color
+	{ 0x3072, 0x0000 }, // Red    = 0x0000
+	{ 0x3074, 0x0000 }, // Green1 = 0x0000
+	{ 0x3076, 0x0FFF }, // Blue   = 0x0FFF
+	{ 0x3078, 0x0000 }, // Green2 = 0x0000
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_cbars_full[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0002 }, // Test Pattern = solid color bars
+	{ 0x3072, 0x0000 }, // Red    = 0x0000
+	{ 0x3074, 0x0000 }, // Green1 = 0x0000
+	{ 0x3076, 0x0000 }, // Blue   = 0x0000
+	{ 0x3078, 0x0000 }, // Green2 = 0x0000
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+static const struct ar0231_reg ar0231_test_pattern_cbars_f2g[] = {
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3070, 0x0003 }, // Test Pattern = fade to grey color bars
+	{ 0x3072, 0x0000 }, // Red    = 0x0000
+	{ 0x3074, 0x0000 }, // Green1 = 0x0000
+	{ 0x3076, 0x0000 }, // Blue   = 0x0000
+	{ 0x3078, 0x0000 }, // Green2 = 0x0000
+	{ 0x307A, 0x0000 }, // ?
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static int ar0231_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	unsigned int val;
+	int ret = 0;
+
+	struct mars_device *dev =
+		container_of(ctrl->handler, struct mars_device, ctrls);
+
+	dev_dbg(dev->dev, "s_ctrl: %s, value: %d.\n",
+		ctrl->name, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		dev_dbg(dev->dev, "set V4L2_CID_EXPOSURE\n");
+		ret = sensor_write(dev, AR0231_COARSE_INTEGRATION_TIME_,
+				   ctrl->val);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		val = ((ctrl->val & 0x0f) << 12) | ((ctrl->val & 0x0f) << 8) |
+			((ctrl->val & 0x0f) << 4) | (ctrl->val & 0x0f);
+		dev_dbg(dev->dev, "set V4L2_CID_ANALOGUE_GAIN 0x%04X\n", val);
+		ret = sensor_write(dev, AR0231_ANALOG_GAIN, val);
+		break;
+	case V4L2_CID_GAIN:
+		dev_dbg(dev->dev, "set V4L2_CID_GAIN\n");
+		ret = sensor_write(dev, AR0231_DIGITAL_GAIN, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		dev_dbg(dev->dev, "set V4L2_CID_HFLIP\n");
+		ret = sensor_read(dev, AR0231_READ_MODE, &val);
+
+		dev_dbg(dev->dev, "old val 0x%04X\n", val);
+
+		if (ret < 0)
+			break;
+		if (ctrl->val)
+			val |= AR0231_READ_MODE_HORIZ_MIRROR;
+		else
+			val &= ~AR0231_READ_MODE_HORIZ_MIRROR;
+
+		dev_dbg(dev->dev, "new val 0x%04X\n", val);
+		ret = sensor_write(dev, AR0231_READ_MODE, val);
+		break;
+	case V4L2_CID_VFLIP:
+		dev_dbg(dev->dev, "set V4L2_CID_VFLIP\n");
+		ret = sensor_read(dev, AR0231_READ_MODE, &val);
+
+		dev_dbg(dev->dev, "old val 0x%04X\n", val);
+
+		if (ret < 0)
+			break;
+		if (ctrl->val)
+			val |= AR0231_READ_MODE_VERT_FLIP;
+		else
+			val &= ~AR0231_READ_MODE_VERT_FLIP;
+
+		dev_dbg(dev->dev, "new val 0x%04X\n", val);
+		ret = sensor_write(dev, AR0231_READ_MODE, val);
+		break;
+	case V4L2_CID_RED_BALANCE:
+		dev_dbg(dev->dev, "set V4L2_CID_RED_BALANCE\n");
+		ret = sensor_write(dev, AR0231_RED_GAIN, ctrl->val);
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		dev_dbg(dev->dev, "set V4L2_CID_BLUE_BALANCE\n");
+		ret = sensor_write(dev, AR0231_BLUE_GAIN, ctrl->val);
+		break;
+	case V4L2_CID_GREEN_BALANCE:
+		dev_dbg(dev->dev, "set V4L2_CID_GREEN_BALANCE\n");
+		ret = sensor_write(dev, AR0231_GREEN1_GAIN, ctrl->val);
+		if (ret < 0)
+			break;
+
+		ret = sensor_write(dev, AR0231_GREEN2_GAIN, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		switch (ctrl->val) {
+		case 0:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_none,
+				ARRAY_SIZE(ar0231_test_pattern_none));
+			break;
+		case 1:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_solid_red,
+				ARRAY_SIZE(ar0231_test_pattern_solid_red));
+			break;
+		case 2:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_solid_green,
+				ARRAY_SIZE(ar0231_test_pattern_solid_green));
+			break;
+		case 3:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_solid_blue,
+				ARRAY_SIZE(ar0231_test_pattern_solid_blue));
+			break;
+		case 4:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_cbars_full,
+				ARRAY_SIZE(ar0231_test_pattern_cbars_full));
+			break;
+		case 5:
+			ret = sensor_set_regs(dev,
+				ar0231_test_pattern_cbars_f2g,
+				ARRAY_SIZE(ar0231_test_pattern_cbars_f2g));
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int mars_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mars_device *dev = sd_to_mars(sd);
+
+	return max96705_set_serial_link(&dev->serializer, enable);
+}
+
+static int mars_enum_mbus_code(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG12_1X12;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+mars_get_pad_format(struct mars_device *dev, struct v4l2_subdev_pad_config *cfg,
+		    unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&dev->sd, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &dev->fmt;
+	default:
+		return NULL;
+	}
+}
+
+static int mars_get_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct mars_device *dev = sd_to_mars(sd);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mutex_lock(&dev->mutex);
+	format->format = *mars_get_pad_format(dev, cfg, format->pad,
+					      format->which);
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+static int mars_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct mars_device *dev = sd_to_mars(sd);
+	struct v4l2_mbus_framefmt *cfg_fmt;
+
+	const struct mars_mode *mode;
+
+	if (format->pad)
+		return -EINVAL;
+
+	cfg_fmt = mars_get_pad_format(dev, cfg, format->pad, format->which);
+	if (!cfg_fmt)
+		return -EINVAL;
+
+	mode = v4l2_find_nearest_size(mars_modes,
+				      ARRAY_SIZE(mars_modes), width, height,
+				      format->format.width,
+				      format->format.height);
+
+	sensor_set_regs(dev, mode->reg_table, MARS_MODE_REG_TABLE_SIZE);
+
+	mutex_lock(&dev->mutex);
+	*cfg_fmt = format->format;
+	cfg_fmt->width = mode->width;
+	cfg_fmt->height = mode->height;
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops mars_video_ops = {
+	.s_stream	= mars_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mars_subdev_pad_ops = {
+	.enum_mbus_code	= mars_enum_mbus_code,
+	.get_fmt	= mars_get_fmt,
+	.set_fmt	= mars_set_fmt,
+};
+
+static const struct v4l2_subdev_ops mars_subdev_ops = {
+	.video		= &mars_video_ops,
+	.pad		= &mars_subdev_pad_ops,
+};
+
+static const struct v4l2_ctrl_ops ar0231_ctrl_ops = {
+	.s_ctrl		= ar0231_s_ctrl,
+};
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Solid Red",
+	"Solid Green",
+	"Solid Blue",
+	"Color Bars (full)",
+	"Color Bars (f2grey)",
+};
+
+const s64 test_pattern_menu_index[] = {0, 1, 2, 3, 4, 5};
+
+static struct v4l2_ctrl_config ar0231_sd_ctrls[] = {
+	{
+		.id = V4L2_CID_PIXEL_RATE,
+		.min    = AR0231_PIXEL_RATE,
+		.max    = AR0231_PIXEL_RATE,
+		.step   = 1,
+		.def    = AR0231_PIXEL_RATE,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_EXPOSURE,
+		.name   = "AR0231 Exposure",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0x10,
+		.max    = 0x53b,
+		.step   = 1,
+		.def    = 0x0335,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_ANALOGUE_GAIN,
+		.name   = "AR0231 Analog Gain",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0,
+		.max    = 0xe,
+		.step   = 1,
+		.def    = 7,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_GAIN,
+		.name   = "AR0231 Digital Gain",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0,
+		.max    = 0x7ff,
+		.step   = 1,
+		.def    = 0x200,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_RED_BALANCE,
+		.name   = "AR0231 Red Balance",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0,
+		.max    = 0x7ff,
+		.step   = 1,
+		.def    = 0x80,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_BLUE_BALANCE,
+		.name   = "AR0231 Blue Balance",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0,
+		.max    = 0x7ff,
+		.step   = 1,
+		.def    = 0x26b,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_GREEN_BALANCE,
+		.name   = "AR0231 Green Balance",
+		.type   = V4L2_CTRL_TYPE_INTEGER,
+		.min    = 0,
+		.max    = 0x7ff,
+		.step   = 1,
+		.def    = 0x91,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_HFLIP,
+		.name   = "AR0231 Horizontal Flip",
+		.type   = V4L2_CTRL_TYPE_BOOLEAN,
+		.min    = 0,
+		.max    = 1,
+		.step   = 1,
+		.def    = 0,
+	}, {
+		.ops    = &ar0231_ctrl_ops,
+		.id = V4L2_CID_VFLIP,
+		.name   = "AR0231 Vertical Flip",
+		.type   = V4L2_CTRL_TYPE_BOOLEAN,
+		.min    = 0,
+		.max    = 1,
+		.step   = 1,
+		.def    = 0,
+	}, {
+		.ops = &ar0231_ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "AR0231 Test Pattern",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(test_pattern_menu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu = test_pattern_menu,
+	},
+};
+
+static void mars_init_format(struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width		= mars_modes[0].width;
+	fmt->height		= mars_modes[0].height;
+	fmt->code		= MEDIA_BUS_FMT_SGRBG12_1X12;
+	fmt->colorspace		= V4L2_COLORSPACE_SRGB;
+	fmt->field		= V4L2_FIELD_NONE;
+	fmt->ycbcr_enc		= V4L2_YCBCR_ENC_DEFAULT;
+	fmt->quantization	= V4L2_QUANTIZATION_DEFAULT;
+	fmt->xfer_func		= V4L2_XFER_FUNC_DEFAULT;
+}
+
+static int mars_initialize(struct mars_device *dev)
+{
+	unsigned int retry = 3;
+	int ret;
+	unsigned int chip_version = 0;
+
+	/* Verify communication with the MAX96705: ping to wakeup. */
+	dev->serializer.client->addr = MAX96705_DEFAULT_ADDR;
+	i2c_smbus_read_byte(dev->serializer.client);
+
+	/* Serial link disabled during config as it needs a valid pixel clock.*/
+	ret = max96705_set_serial_link(&dev->serializer, false);
+	if (ret)
+		return ret;
+
+	ret = max96705_configure_gmsl_link(&dev->serializer);
+	if (ret)
+		return ret;
+
+	ret = max96705_verify_id(&dev->serializer);
+	if (ret < 0)
+		return ret;
+
+	ret = max96705_set_address(&dev->serializer, dev->addrs[0]);
+	if (ret < 0)
+		return ret;
+	dev->serializer.client->addr = dev->addrs[0];
+
+	ret = max96705_set_translation(&dev->serializer, dev->addrs[1], 0x10);
+	if (ret < 0)
+		return ret;
+
+	dev->sensor_regmap = devm_regmap_init_i2c(dev->sensor,
+						  &sensor_regmap_config);
+	if (IS_ERR(dev->sensor_regmap)) {
+		dev_err(dev->dev, "sensor_regmap init failed: %ld\n",
+			PTR_ERR(dev->sensor_regmap));
+		return -ENODEV;
+	}
+
+	ret = sensor_read(dev, 0x3000, &chip_version);
+	if (ret < 0) {
+		dev_err(dev->dev, "sensor_read failed (%d)\n",
+			ret);
+		return ret;
+	}
+
+	if (chip_version != 0x0354) {
+		dev_err(dev->dev, "sensor ID mismatch (0x%04x)\n",
+			chip_version);
+		return -ENXIO;
+	}
+
+	/* RESET_REGISTER */
+	ret = sensor_write(dev, 0x301A, 0x10D8);
+	if (ret)
+		return ret;
+
+	/* wait at least 700ms */
+	usleep_range(700000, 1000000);
+
+	ret = sensor_set_regs(dev, ar0231_config_part1,
+			 ARRAY_SIZE(ar0231_config_part1));
+	if (ret)
+		return ret;
+
+	ret = sensor_set_regs(dev, ar0231_config_part1b,
+			 ARRAY_SIZE(ar0231_config_part1b));
+	if (ret)
+		return ret;
+
+	ret = sensor_set_regs(dev, ar0231_config_part2,
+			 ARRAY_SIZE(ar0231_config_part2));
+	if (ret)
+		return ret;
+
+	ret = sensor_set_regs(dev, ar0231_config_part6_exposure,
+			 ARRAY_SIZE(ar0231_config_part6_exposure));
+	if (ret)
+		return ret;
+
+	ret = sensor_set_regs(dev, ar0231_config_part7_gains,
+			 ARRAY_SIZE(ar0231_config_part7_gains));
+	if (ret)
+		return ret;
+
+	dev_info(dev->dev, "Identified MARS camera module\n");
+
+	/*
+	 * Set reverse channel high threshold to increase noise immunity.
+	 *
+	 * This should be compensated by increasing the reverse channel
+	 * amplitude on the remote deserializer side.
+	 */
+	return max96705_set_high_threshold(&dev->serializer, true);
+}
+
+static int mars_probe(struct i2c_client *client)
+{
+	struct mars_device *dev;
+	struct fwnode_handle *ep;
+	int num_ctrls;
+	int i;
+	int ret;
+
+	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+	dev->dev = &client->dev;
+
+	mutex_init(&dev->mutex);
+
+
+	dev->serializer.client = client;
+
+	ret = of_property_read_u32_array(client->dev.of_node, "reg",
+					 dev->addrs, 2);
+	if (ret < 0) {
+		dev_err(dev->dev, "Invalid DT reg property: %d\n", ret);
+		return -EINVAL;
+	}
+
+	/* Create the dummy I2C client for the sensor. */
+	dev->sensor = i2c_new_dummy_device(client->adapter,
+					   dev->addrs[1]);
+	if (IS_ERR(dev->sensor)) {
+		ret = PTR_ERR(dev->sensor);
+		goto error;
+	}
+
+	/* Initialize the hardware. */
+	ret = mars_initialize(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "mars_initialize: %d\n", ret);
+		return ret;
+	}
+
+	mars_init_format(&dev->fmt);
+
+	/* Initialize and register the subdevice. */
+	v4l2_i2c_subdev_init(&dev->sd, client, &mars_subdev_ops);
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	num_ctrls = ARRAY_SIZE(ar0231_sd_ctrls);
+	dev_dbg(dev->dev, "# of ctrls = %d\n", num_ctrls);
+
+	v4l2_ctrl_handler_init(&dev->ctrls, num_ctrls + 1);
+
+	v4l2_ctrl_new_std(&dev->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  AR0231_PIXEL_RATE, AR0231_PIXEL_RATE, 1,
+			  AR0231_PIXEL_RATE);
+
+	for (i = 0; i < num_ctrls; i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(dev->dev, "%d ctrl %s = 0x%x\n",
+			i, ar0231_sd_ctrls[i].name, ar0231_sd_ctrls[i].id);
+
+		ctrl = v4l2_ctrl_new_custom(&dev->ctrls,
+						&ar0231_sd_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_err(dev->dev, "Failed for %s ctrl\n",
+				ar0231_sd_ctrls[i].name);
+			goto error_free_ctrls;
+		}
+	}
+
+	dev_dbg(dev->dev, "# v4l2 ctrls registered = %d\n", i - 1);
+
+	dev->sd.ctrl_handler = &dev->ctrls;
+
+	ret = dev->ctrls.error;
+	if (ret)
+		goto error_free_ctrls;
+
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);
+	if (ret < 0)
+		goto error_free_ctrls;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev,
+			"Unable to get endpoint in node %pOF\n",
+			client->dev.of_node);
+		ret = -ENOENT;
+		goto error_free_ctrls;
+	}
+	dev->sd.fwnode = ep;
+
+	ret = v4l2_async_register_subdev(&dev->sd);
+	if (ret)
+		goto error_put_node;
+
+	return 0;
+
+error_put_node:
+	fwnode_handle_put(ep);
+error_free_ctrls:
+	v4l2_ctrl_handler_free(&dev->ctrls);
+error:
+	media_entity_cleanup(&dev->sd.entity);
+	if (dev->sensor)
+		i2c_unregister_device(dev->sensor);
+
+	dev_err(&client->dev, "probe failed\n");
+
+	return ret;
+}
+
+static int mars_remove(struct i2c_client *client)
+{
+	struct mars_device *dev = i2c_to_mars(client);
+
+	fwnode_handle_put(dev->sd.fwnode);
+	v4l2_async_unregister_subdev(&dev->sd);
+	v4l2_ctrl_handler_free(&dev->ctrls);
+	media_entity_cleanup(&dev->sd.entity);
+	i2c_unregister_device(dev->sensor);
+
+	mutex_destroy(&dev->mutex);
+
+	return 0;
+}
+
+static void mars_shutdown(struct i2c_client *client)
+{
+	struct mars_device *dev = i2c_to_mars(client);
+
+	/* make sure stream off during shutdown (reset/reboot) */
+	mars_s_stream(&dev->sd, 0);
+}
+
+static const struct of_device_id mars_of_ids[] = {
+	{ .compatible = "onnn,mars", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mars_of_ids);
+
+static struct i2c_driver mars_i2c_driver = {
+	.driver	= {
+		.name	= "mars",
+		.of_match_table = mars_of_ids,
+	},
+	.probe_new	= mars_probe,
+	.remove		= mars_remove,
+	.shutdown	= mars_shutdown,
+};
+
+module_i2c_driver(mars_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL Camera driver for Mars");
+MODULE_AUTHOR("Thomas Nizan");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/mars.h b/drivers/media/i2c/mars.h
new file mode 100644
index 0000000..04e81d0
--- /dev/null
+++ b/drivers/media/i2c/mars.h
@@ -0,0 +1,395 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ */
+
+#include <linux/types.h>
+
+struct ar0231_reg {
+	u16 reg;
+	u16  val;
+};
+
+static const struct ar0231_reg ar0231_config_part1[] = {
+	{ 0x3056, 0x0080 }, // GREEN1_GAIN
+	{ 0x3058, 0x0080 }, // BLUE_GAIN
+	{ 0x305A, 0x0080 }, // RED_GAIN
+	{ 0x305C, 0x0080 }, // GREEN2_GAIN
+	{ 0x3138, 0x000B }, // OTPM_TCFG_OPT
+	{ 0x30FE, 0x0020 }, // NOISE_PEDESTAL
+	{ 0x3372, 0xF54F }, // DBLC_FS0_CONTROL
+	{ 0x337A, 0x0D70 }, // DBLC_SCALE0
+	{ 0x337E, 0x1FFD }, // DBLC_OFFSET0
+	{ 0x3382, 0x00C0 }, // DBLC_WEIGHT0
+	{ 0x3092, 0x0024 }, // ROW_NOISE_CONTROL
+	{ 0x3C04, 0x0E80 }, // RESERVED_MFR_3C04
+	{ 0x3F90, 0x06E1 }, // TEMPVSENS0_TMG_CTRL
+	{ 0x3F92, 0x06E1 }, // TEMPVSENS1_TMG_CTRL
+	{ 0x350E, 0xFF14 }, // RESERVED_MFR_350E
+	{ 0x3506, 0x4444 }, // RESERVED_MFR_3506
+	{ 0x3508, 0x4444 }, // RESERVED_MFR_3508
+	{ 0x350A, 0x4465 }, // RESERVED_MFR_350A
+	{ 0x350C, 0x055F }, // RESERVED_MFR_350C
+	{ 0x30BA, 0x11F0 }, // DIGITAL_CTRL
+	{ 0x3566, 0x1D28 }, // RESERVED_MFR_3566
+	{ 0x3518, 0x1FFE }, // RESERVED_MFR_3518
+	{ 0x318E, 0x0200 }, // DLO_CONTROL0
+	{ 0x3190, 0x5000 }, // RESERVED_MFR_3190
+	{ 0x319E, 0x6060 }, // RESERVED_MFR_319E
+	{ 0x3520, 0x4688 }, // RESERVED_MFR_3520
+	{ 0x3522, 0x8840 }, // RESERVED_MFR_3522
+	{ 0x3524, 0x4046 }, // RESERVED_MFR_3524
+	{ 0x352C, 0xC6C6 }, // RESERVED_MFR_352C
+	{ 0x352A, 0x089F }, // RESERVED_MFR_352A
+	{ 0x352E, 0x0011 }, // RESERVED_MFR_352E
+	{ 0x352E, 0x0011 }, // RESERVED_MFR_352E
+	{ 0x3530, 0x4400 }, // RESERVED_MFR_3530
+	{ 0x3530, 0x4400 }, // RESERVED_MFR_3530
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3536, 0xFF06 }, // RESERVED_MFR_3536
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x3538, 0xFFFF }, // RESERVED_MFR_3538
+	{ 0x353A, 0x9000 }, // RESERVED_MFR_353A
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x353C, 0x3F00 }, // RESERVED_MFR_353C
+	{ 0x32EC, 0x72A1 }, // RESERVED_MFR_32EC
+	{ 0x3540, 0xC63E }, // RESERVED_MFR_3540
+	{ 0x3540, 0xC63E }, // RESERVED_MFR_3540
+	{ 0x3556, 0x101F }, // RESERVED_MFR_3556
+	{ 0x3566, 0x1D28 }, // RESERVED_MFR_3566
+	{ 0x3566, 0x1D28 }, // RESERVED_MFR_3566
+	{ 0x3566, 0x1D28 }, // RESERVED_MFR_3566
+	{ 0x3566, 0x1128 }, // RESERVED_MFR_3566
+	{ 0x3566, 0x1328 }, // RESERVED_MFR_3566
+	{ 0x3566, 0x3328 }, // RESERVED_MFR_3566
+	{ 0x3528, 0xDDDD }, // RESERVED_MFR_3528
+	{ 0x3540, 0xC63E }, // RESERVED_MFR_3540
+	{ 0x3542, 0x545B }, // RESERVED_MFR_3542
+	{ 0x3544, 0x645A }, // RESERVED_MFR_3544
+	{ 0x3546, 0x5A5A }, // RESERVED_MFR_3546
+	{ 0x3548, 0x6400 }, // RESERVED_MFR_3548
+};
+
+
+static const struct ar0231_reg ar0231_config_part1b[] = {
+	{ 0x2512, 0x8000 }, // SEQ_CTRL_PORT
+	{ 0x2510, 0x0905 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x3350 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x2004 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1460 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1578 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1360 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x7B24 }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFF24 }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFF24 }, // SEQ_DATA_PORT
+	{ 0x2510, 0xEA24 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1022 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x2410 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x155A }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1342 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1400 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x24FF }, // SEQ_DATA_PORT
+	{ 0x2510, 0x24FF }, // SEQ_DATA_PORT
+	{ 0x2510, 0x24EA }, // SEQ_DATA_PORT
+	{ 0x2510, 0x2324 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x647A }, // SEQ_DATA_PORT
+	{ 0x2510, 0x2404 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x052C }, // SEQ_DATA_PORT
+	{ 0x2510, 0x400A }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFF0A }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFF0A }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1808 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x3851 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1440 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0004 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0801 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0408 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1180 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x15DC }, // SEQ_DATA_PORT
+	{ 0x2510, 0x134C }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1002 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1016 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1181 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1189 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1056 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1210 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0D08 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0913 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x13C8 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x092B }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1588 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1388 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0909 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11D9 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x091D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1441 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0903 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1214 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x10D6 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1210 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1212 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1210 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11DD }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11D9 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1056 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0905 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11DB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x092B }, // SEQ_DATA_PORT
+	{ 0x2510, 0x119B }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11BB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x121A }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1210 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1460 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1250 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1076 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x10E6 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x15AB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x13A8 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1240 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1260 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0923 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x158D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x138D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0B09 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0108 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1440 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x091D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1588 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1388 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x092D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1066 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0905 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0C08 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x090B }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1441 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x090D }, // SEQ_DATA_PORT
+	{ 0x2510, 0x10E6 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0901 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1262 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1260 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11BF }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11BB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1066 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11FB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0935 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11BB }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1263 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1260 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1400 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1510 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x11B8 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x12A0 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1200 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1026 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1000 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1342 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x1100 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x7A06 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0913 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0507 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x0841 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x3750 }, // SEQ_DATA_PORT
+	{ 0x2510, 0x2C2C }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFE05 }, // SEQ_DATA_PORT
+	{ 0x2510, 0xFE13 }, // SEQ_DATA_PORT
+	{ 0x1008, 0x0361 }, // RESERVED_PARAM_1008
+	{ 0x100C, 0x0589 }, // RESERVED_PARAM_100C
+	{ 0x100E, 0x07B1 }, // RESERVED_PARAM_100E
+	{ 0x1010, 0x0139 }, // RESERVED_PARAM_1010
+	{ 0x3230, 0x0304 }, // FINE_CORRECTION
+	{ 0x3232, 0x052C }, // FINE_CORRECTION2
+	{ 0x3234, 0x0754 }, // FINE_CORRECTION3
+	{ 0x3236, 0x00DC }, // FINE_CORRECTION4
+	{ 0x3566, 0x3328 }, // RESERVED_MFR_3566
+	{ 0x350C, 0x055F }, // RESERVED_MFR_350C
+	{ 0x32D0, 0x3A02 }, // RESERVED_MFR_32D0
+	{ 0x32D2, 0x3508 }, // RESERVED_MFR_32D2
+	{ 0x32D4, 0x3702 }, // RESERVED_MFR_32D4
+	{ 0x32D6, 0x3C04 }, // RESERVED_MFR_32D6
+	{ 0x32DC, 0x370A }, // RESERVED_MFR_32DC
+};
+
+static const struct ar0231_reg ar0231_config_part2[] = {
+	// ar0231_config_part2_75mhz[] = {
+	// PLL 27MHz In - 75MHz out
+	{ 0x302A, 0x0008 }, //VT_PIX_CLK_DIV = 8
+	{ 0x302C, 0x0001 }, //VT_SYS_CLK_DIV = 1
+	{ 0x302E, 0x0009 }, //PRE_PLL_CLK_DIV = 9
+	{ 0x3030, 0x00C8 }, //PLL_MULTIPLIER = 200
+	{ 0x3036, 0x0008 }, //OP_PIX_CLK_DIV = 8
+	{ 0x3038, 0x0001 }, //OP_SYS_CLK_DIV = 1
+	// ar0231_config_part3[] = {
+	{ 0x30B0, 0x0B00 }, // DIGITAL_TEST - [8] PIXCLK_ON
+						// continuous clock mode
+	{ 0x30A2, 0x0001 }, // X_ODD_INC_ (1 == no skip)
+	{ 0x30A6, 0x0001 }, // Y_ODD_INC_ (1 == no skip)
+	{ 0x3040, 0x0000 }, // READ_MODE
+	{ 0x3040, 0x0000 }, // READ_MODE
+	{ 0x3082, 0x0000 }, // OPERATION_MODE_CTRL
+	{ 0x3082, 0x0000 }, // OPERATION_MODE_CTRL
+	{ 0x3082, 0x0000 }, // OPERATION_MODE_CTRL
+	{ 0x3082, 0x0000 }, // OPERATION_MODE_CTRL
+	{ 0x30BA, 0x11F0 }, // DIGITAL_CTRL
+	{ 0x30BA, 0x11F0 }, // DIGITAL_CTRL
+	{ 0x30BA, 0x11F0 }, // DIGITAL_CTRL
+	{ 0x3044, 0x0400 }, // DARK_CONTROL
+	{ 0x3044, 0x0400 }, // DARK_CONTROL
+	{ 0x3044, 0x0400 }, // DARK_CONTROL
+	{ 0x3044, 0x0400 }, // DARK_CONTROL
+	{ 0x3064, 0x1802 }, // SMIA_TEST
+	{ 0x3064, 0x1802 }, // SMIA_TEST
+	{ 0x3064, 0x1802 }, // SMIA_TEST
+	{ 0x3064, 0x1802 }, // SMIA_TEST
+	{ 0x33E0, 0x0C80 }, // TEST_ASIL_ROWS
+	{ 0x33E0, 0x0C80 }, // TEST_ASIL_ROWS
+	{ 0x3180, 0x0080 }, // RESERVED_MFR_3180
+	{ 0x33E4, 0x0080 }, // RESERVED_MFR_33E4
+	{ 0x33E0, 0x0C80 }, // TEST_ASIL_ROWS
+	{ 0x33E0, 0x0C80 }, // TEST_ASIL_ROWS
+	//ar0231_config_part4_1080p[] = {
+	{ 0x3004, 0x0000 }, // X_ADDR_START = 0
+	{ 0x3008, 0x077F }, // X_ADDR_END = 1919
+	{ 0x3002, 0x003C }, // Y_ADDR_START = 60
+	{ 0x3006, 0x0473 }, // Y_ADDR_END = 1139 ... 1139-60
+					   // =1079
+	{ 0x3032, 0x0000 }, // SCALING_MODE
+	{ 0x3400, 0x0010 }, // RESERVED_MFR_3400
+	{ 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+	{ 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+	{ 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+	{ 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+	// ar0231_config_part5a[] = {
+	{ 0x3082, 0x0000 },  // OPERATION_MODE_CTRL
+	{ 0x30BA, 0x11F1 },  // DIGITAL_CTRL
+		//0x00, 100, // DELAY= 100
+	{ 0x30BA, 0x11F0 },  // DIGITAL_CTRL
+	//ar0231_config_part5b_1080p[] = {
+	{ 0x300C, 0x080E },  // LINE_LENGTH_PCK_ = 2062
+	{ 0x300A, 0x0484 },  // FRAME_LENGTH_LINES_ = 1156
+	{ 0x3042, 0x0000 },  // EXTRA_DELAY = 0
+						// TOTAL CYCLES = 2062*1156 + 0
+						// = 2,383,672
+	//ar0231_config_part5c[] = {
+	{ 0x3238, 0x0222 },  // EXPOSURE_RATIO
+	{ 0x3238, 0x0222 },  // EXPOSURE_RATIO
+	{ 0x3238, 0x0222 },  // EXPOSURE_RATIO
+	{ 0x3238, 0x0222 },  // EXPOSURE_RATIO
+	{ 0x3012, 0x0163 },  // COARSE_INTEGRATION_TIME_
+	{ 0x3014, 0x06A4 },  // FINE_INTEGRATION_TIME_
+	{ 0x30B0, 0x0B00 },  // DIGITAL_TEST - [8] PIXCLK_ON
+							// continuous clock mode
+	{ 0x32EA, 0x3C08 },  // RESERVED_MFR_32EA
+	{ 0x32EA, 0x3C08 },  // RESERVED_MFR_32EA
+	{ 0x32EA, 0x3C08 },  // RESERVED_MFR_32EA
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x32EC, 0x72A1 },  // RESERVED_MFR_32EC
+	{ 0x31D0, 0x0000 },  // COMPANDING
+	{ 0x31AE, 0x0001 },  // SERIAL_FORMAT
+	{ 0x31AE, 0x0001 },  // SERIAL_FORMAT
+	{ 0x31AC, 0x0C0C },  // DATA_FORMAT_BITS
+	{ 0x31AC, 0x0C0C },  // DATA_FORMAT_BITS
+	// Enable external synchronization
+	{ 0x340A, 0x0077 },  // GPIO_CONTROL1
+						// [ 7] GPIO3_INPUT_DISABLE = 0
+						// [ 6] GPIO2_INPUT_DISABLE = 1
+						// [ 5] GPIO1_INPUT_DISABLE = 1
+						// [ 4] GPIO0_INPUT_DISABLE = 1
+						// [ 7] GPIO3_OUTPUT_ENABLE = 0
+						// [ 6] GPIO2_OUTPUT_ENABLE = 1
+						// [ 5] GPIO1_OUTPUT_ENABLE = 1
+						// [ 4] GPIO0_OUTPUT_ENABLE = 1
+	{ 0x340C, 0x0080 },  // GPIO_CONTROL2
+						//    [11] GPIO_HIDRV_EN = 0
+						//         (1.8V)
+						// [10: 8] GPIO_SLEW = 000
+						// [ 7: 6] GPIO3_ISEL = 10
+						//     (TRIGGER)
+						// [ 5: 4] GPIO2_ISEL = 00
+						//     (none)
+						// [ 3: 2] GPIO1_ISEL = 00
+						//     (none)
+						// [ 1: 0] GPIO0_ISEL = 00
+						//     (none)
+	{ 0x30CE, 0x0120 },  // GRR_CONTROL1, Trigger
+						// Shutter Sync
+						// (Surround View Slave) Mode
+						//  [ 8] SLAVE_SH_SYNC_MODE = 1
+						//  [ 7] SHUTTER_ALWAYS_OPEN
+						//  [ 6] SHUTTER_DISABLE
+						//  [ 5] FRAME_START_MODE /
+						//       FRAME_START_SYNCED = 1
+						//  [ 4] SLAVE_MODE
+						//  [ 2] EXT_SHUT_PULSED
+						//  [ 1] LINE_SYNC_MODE
+						//  [ 0] GRR_MODE
+	{ 0x301A, 0x19DC },  // RESET_REGISTER
+						//  [15] GROUPED_PARAMETER_HOLD
+						//       = 0
+						//  [14] RSVD
+						//  [13] LPF_ENABLE = 0
+						//  [12] SMIA_SERIALIZER_DIS= 1
+						//  [11] FORCED_PLL_ON = 1
+						//  [10] RESTART_BAD   = 0
+						//  [ 9] MASK_BAD      = 0
+						//  [ 8] GPI_EN        = 1
+						//  [ 7] PARALLEL_EN = 1
+						//  [ 6] DRIVE_PINS  = 1
+						//  [ 5] RSVD
+						//  [ 4] UNUSED      = 1
+						//  [ 3] LOCK_REG = 1
+						//  [ 2] STREAM   = 1
+						//  [ 1] RESTART  = 0
+						//  [ 0] RESET    = 0
+};
+
+static const struct ar0231_reg ar0231_config_part6_exposure[] = {
+	// Adjust Integration Time
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3012, 0x0335 }, // COARSE_INTEGRATION_TIME_
+	{ 0x3014, 0x06A4 }, // FINE_INTEGRATION_TIME_
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_config_part7_gains[] = {
+	// Adust Gains
+	{ 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+	{ 0x3362, 0x0000 }, // DC_GAIN
+	{ 0x3366, 0x7777 }, // ANALOG_GAIN
+	{ 0x3056, 0x0091 }, // GREEN1_GAIN
+	{ 0x305C, 0x0091 }, // GREEN2_GAIN
+	{ 0x305A, 0x0080 }, // RED_GAIN
+	{ 0x3058, 0x026B }, // BLUE_GAIN
+	{ 0x3308, 0x0200 }, // DIG_GAIN_GLOBAL
+	{ 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
diff --git a/drivers/media/i2c/max96705.c b/drivers/media/i2c/max96705.c
new file mode 100644
index 0000000..d0f7a2b
--- /dev/null
+++ b/drivers/media/i2c/max96705.c
@@ -0,0 +1,469 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * This file exports functions to control the Maxim MAX96705 GMSL serializer
+ * chip. This is not a self-contained driver, as MAX96705 is usually embedded in
+ * camera modules with at least one image sensor and optional additional
+ * components, such as uController units or ISPs/DSPs.
+ *
+ * Drivers for the camera modules (i.e. mars module) are expected to use
+ * functions exported from this library driver to maximize code re-use.
+ */
+
+#define DEBUG
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+
+#include "max96705.h"
+
+int max96705_read(struct max96705_device *dev, u8 reg)
+{
+	int ret;
+	int retry = 5;
+
+	dev_dbg(&dev->client->dev, "%s(0x%02x)\n", __func__, reg);
+
+	while (retry--) {
+		ret = i2c_smbus_read_byte_data(dev->client, reg);
+		if (ret < 0) {
+			dev_err(&dev->client->dev,
+				"%s: register 0x%02x read failed (%d)\n",
+				__func__, reg, ret);
+		} else {
+			break;
+		}
+		usleep_range(5000, 10000);
+	}
+
+	if (ret < 0)
+		dev_err(&dev->client->dev,
+			"%s: register 0x%02x read failed (%d) - all retries failed\n",
+			__func__, reg, ret);
+
+	return ret;
+}
+
+int max96705_write(struct max96705_device *dev, u8 reg, u8 val)
+{
+	int ret;
+	int retry = 5;
+
+	dev_dbg(&dev->client->dev, "%s(0x%02x, 0x%02x)\n", __func__, reg, val);
+
+	while (retry--) {
+		ret = i2c_smbus_write_byte_data(dev->client, reg, val);
+		if (ret < 0) {
+			dev_err(&dev->client->dev,
+				"%s: register 0x%02x write failed (%d)\n",
+				__func__, reg, ret);
+		} else {
+			break;
+		}
+		usleep_range(5000, 10000);
+	}
+
+	if (ret < 0)
+		dev_err(&dev->client->dev,
+			"%s: register 0x%02x write failed (%d) - all retries failed\n",
+			__func__, reg, ret);
+
+	return ret;
+}
+
+/*
+ * max96705_pclk_detect() - Detect valid pixel clock from image sensor
+ *
+ * Wait up to 10ms for a valid pixel clock.
+ *
+ * Returns 0 for success, < 0 for pixel clock not properly detected
+ */
+static int max96705_pclk_detect(struct max96705_device *dev)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < 100; i++) {
+		ret = max96705_read(dev, 0x15);
+		if (ret < 0)
+			return ret;
+
+		if (ret & MAX96705_PCLKDET)
+			return 0;
+
+		usleep_range(50, 100);
+	}
+
+	dev_err(&dev->client->dev, "Unable to detect valid pixel clock\n");
+
+	return -EIO;
+}
+
+int max96705_set_serial_link(struct max96705_device *dev, bool enable)
+{
+	int ret;
+	u8 val = MAX96705_REVCCEN | MAX96705_FWDCCEN;
+
+	if (enable) {
+		ret = max96705_pclk_detect(dev);
+		if (ret)
+			return ret;
+
+		val |= MAX96705_SEREN;
+	} else {
+		val |= MAX96705_CLINKEN;
+	}
+
+	/*
+	 * The serializer temporarily disables the reverse control channel for
+	 * 350µs after starting/stopping the forward serial link, but the
+	 * deserializer synchronization time isn't clearly documented.
+	 *
+	 * According to the serializer datasheet we should wait 3ms, while
+	 * according to the deserializer datasheet we should wait 5ms.
+	 *
+	 * Short delays here appear to show bit-errors in the writes following.
+	 * Therefore a conservative delay seems best here.
+	 */
+	ret = max96705_write(dev, 0x04, val);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(5000, 8000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_serial_link);
+
+int max96705_configure_i2c(struct max96705_device *dev, u8 i2c_config)
+{
+	int ret;
+
+	ret = max96705_write(dev, 0x0d, i2c_config);
+	if (ret < 0)
+		return ret;
+
+	/* The delay required after an I2C bus configuration change is not
+	 * characterized in the serializer manual. Sleep up to 5msec to
+	 * stay safe.
+	 */
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_configure_i2c);
+
+int max96705_set_high_threshold(struct max96705_device *dev, bool enable)
+{
+
+	/*
+	 * WORK IN PROGRESS: Experiencing some issues writing/reading registers
+	 * 0x08 and 0x97
+	 * Reg 0x97 is sometimes initialized with value 0xff (instead of 0x1f)
+	 *      when this happens, I can't read this register, but the driver
+	 *      will keep working later
+	 *
+	 * Currently trying to get more information on this registers
+	 */
+
+	int ret;
+	int retry = 5;
+	int write_cmd = 0;
+
+	ret = max96705_read(dev, 0x97);
+
+	dev_info(&dev->client->dev, "max96705_read 0x97:  read 0x%02x\n", ret);
+
+	ret = max96705_read(dev, 0x08);
+	if (ret < 0)
+		return ret;
+
+	dev_info(&dev->client->dev, "max96705_read 0x08:  read 0x%02x\n", ret);
+
+	/*
+	 * Enable or disable reverse channel high threshold to increase
+	 * immunity to power supply noise.
+	 */
+
+	write_cmd = enable ? ret | BIT(0) : ret & ~BIT(0);
+	while (retry--) {
+		ret = max96705_write(dev, 0x08, write_cmd);
+
+		usleep_range(200000, 250000);
+
+		ret = max96705_read(dev, 0x08);
+
+		dev_info(&dev->client->dev, "max96705_read 0x08: read 0x%02x\n",
+			 ret);
+
+		if (write_cmd == ret)
+			break;
+	}
+
+	if (retry < 0) {
+		dev_info(&dev->client->dev,
+			 "FAILED TO WRITE CORRECTLY 0x08: ret = 0x%02x\n", ret);
+	}
+
+	retry = 5;
+	write_cmd = 0x5F;
+
+	while (retry--) {
+		ret = max96705_write(dev, 0x97, write_cmd);
+
+		usleep_range(200000, 250000);
+
+		ret = max96705_read(dev, 0x97);
+		dev_info(&dev->client->dev, "max96705_read 0x97: read 0x%02x\n",
+			 ret);
+
+		if (write_cmd == ret)
+			break;
+	}
+
+	if (retry < 0) {
+		dev_info(&dev->client->dev,
+			 "FAILED TO WRITE CORRECTLY 0x97: ret = 0x%02x\n", ret);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_high_threshold);
+
+int max96705_configure_gmsl_link(struct max96705_device *dev)
+{
+	int ret;
+
+	/*
+	 * Configure the GMSL link:
+	 *
+	 * - Double input mode, High-Bandwidth, 24-bit mode
+	 * - Enable HS/VS encoding
+	 * - 1-bit parity error detection
+	 *
+	 * TODO: Make the GMSL link configuration parametric.
+	 */
+	ret = max96705_write(dev, 0x07, MAX96705_DBL | MAX96705_HIBW |
+				  MAX96705_HVEN | MAX96705_EDC_1BIT_PARITY);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(5000, 8000);
+
+	ret = max96705_write(dev, 0x06, 0xAC);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(5000, 8000);
+
+	/*
+	 * Enable vsync re-gen (VS internally generated),
+	 * falling edge triggers one VS frame
+	 */
+	ret = max96705_write(dev, 0x43, MAX96705_GEN_VS |
+			     MAX96705_VS_TRIG_FALL |
+			     MAX96705_VTG_MODE_VS_FRAME);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Set VSync Delay,  should be on the order of 4 lines or more:
+	 * 2162 * 4 = 8648 (0x21C8)
+	 */
+	ret = max96705_write(dev, 0x44, 0x00);
+	if (ret < 0)
+		return ret;
+
+	ret = max96705_write(dev, 0x45, 0x21);
+	if (ret < 0)
+		return ret;
+
+	ret = max96705_write(dev, 0x46, 0xC8);
+	if (ret < 0)
+		return ret;
+
+	/* Set VSync High time, should be > 200 (0xC8) Pclks */
+	ret = max96705_write(dev, 0x47, 0x00);
+	if (ret < 0)
+		return ret;
+
+	ret = max96705_write(dev, 0x48, 0x00);
+	if (ret < 0)
+		return ret;
+
+	ret = max96705_write(dev, 0x49, 0xC8);
+	if (ret < 0)
+		return ret;
+
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_configure_gmsl_link);
+
+int max96705_set_gpios(struct max96705_device *dev, u8 gpio_mask)
+{
+	int ret;
+
+	ret = max96705_read(dev, 0x0f);
+	if (ret < 0)
+		return 0;
+
+	ret |= gpio_mask;
+	ret = max96705_write(dev, 0x0f, ret);
+	if (ret < 0) {
+		dev_err(&dev->client->dev, "Failed to set gpio (%d)\n", ret);
+		return ret;
+	}
+
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_gpios);
+
+int max96705_clear_gpios(struct max96705_device *dev, u8 gpio_mask)
+{
+	int ret;
+
+	ret = max96705_read(dev, 0x0f);
+	if (ret < 0)
+		return 0;
+
+	ret &= ~gpio_mask;
+	ret = max96705_write(dev, 0x0f, ret);
+	if (ret < 0) {
+		dev_err(&dev->client->dev, "Failed to clear gpio (%d)\n", ret);
+		return ret;
+	}
+
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_clear_gpios);
+
+int max96705_enable_gpios(struct max96705_device *dev, u8 gpio_mask)
+{
+	int ret;
+
+	ret = max96705_read(dev, 0x0e);
+	if (ret < 0)
+		return 0;
+
+	/* BIT(0) reserved: GPO is always enabled. */
+	ret |= (gpio_mask & ~BIT(0));
+	ret = max96705_write(dev, 0x0e, ret);
+	if (ret < 0) {
+		dev_err(&dev->client->dev, "Failed to enable gpio (%d)\n", ret);
+		return ret;
+	}
+
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_enable_gpios);
+
+int max96705_disable_gpios(struct max96705_device *dev, u8 gpio_mask)
+{
+	int ret;
+
+	ret = max96705_read(dev, 0x0e);
+	if (ret < 0)
+		return 0;
+
+	/* BIT(0) reserved: GPO cannot be disabled */
+	ret &= ~(gpio_mask | BIT(0));
+	ret = max96705_write(dev, 0x0e, ret);
+	if (ret < 0) {
+		dev_err(&dev->client->dev, "Failed to disable gpio (%d)\n",
+			ret);
+		return ret;
+	}
+
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_disable_gpios);
+
+int max96705_verify_id(struct max96705_device *dev)
+{
+	int ret;
+
+	ret = max96705_read(dev, 0x1e);
+	if (ret < 0) {
+		dev_err(&dev->client->dev, "MAX96705 ID read failed (%d)\n",
+			ret);
+		return ret;
+	}
+
+	if (ret != MAX96705_ID) {
+		dev_err(&dev->client->dev, "MAX96705 ID mismatch (0x%02x)\n",
+			ret);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_verify_id);
+
+int max96705_set_address(struct max96705_device *dev, u8 addr)
+{
+	int ret;
+
+	ret = max96705_write(dev, 0x00, addr << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C address change failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_address);
+
+int max96705_set_deserializer_address(struct max96705_device *dev, u8 addr)
+{
+	int ret;
+
+	ret = max96705_write(dev, 0x01, addr << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 deserializer address set failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_deserializer_address);
+
+int max96705_set_translation(struct max96705_device *dev, u8 source, u8 dest)
+{
+	int ret;
+
+	ret = max96705_write(dev, 0x09, source << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C translation setup failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	ret = max96705_write(dev, 0x0a, dest << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C translation setup failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max96705_set_translation);
+
+MODULE_DESCRIPTION("Maxim MAX96705 GMSL Serializer");
+MODULE_AUTHOR("Thomas Nizan");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/max96705.h b/drivers/media/i2c/max96705.h
new file mode 100644
index 0000000..af517e2
--- /dev/null
+++ b/drivers/media/i2c/max96705.h
@@ -0,0 +1,210 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ */
+
+#include <linux/i2c.h>
+
+#define MAX96705_DEFAULT_ADDR	0x40
+
+/* Register 0x04 */
+#define MAX96705_SEREN			BIT(7)
+#define MAX96705_CLINKEN			BIT(6)
+#define MAX96705_PRBSEN			BIT(5)
+#define MAX96705_SLEEP			BIT(4)
+#define MAX96705_INTTYPE_I2C		(0 << 2)
+#define MAX96705_INTTYPE_UART		(1 << 2)
+#define MAX96705_INTTYPE_NONE		(2 << 2)
+#define MAX96705_REVCCEN			BIT(1)
+#define MAX96705_FWDCCEN			BIT(0)
+/* Register 0x07 */
+#define MAX96705_DBL			BIT(7)
+#define MAX96705_HIBW			BIT(6)
+#define MAX96705_BWS			BIT(5)
+#define MAX96705_ES			BIT(4)
+#define MAX96705_HVEN			BIT(2)
+#define MAX96705_EDC_1BIT_PARITY		(0 << 0)
+#define MAX96705_EDC_6BIT_CRC		(1 << 0)
+/* Register 0x0d */
+#define MAX96705_I2CLOCACK		BIT(7)
+#define MAX96705_I2CSLVSH_1046NS_469NS	(3 << 5)
+#define MAX96705_I2CSLVSH_938NS_352NS	(2 << 5)
+#define MAX96705_I2CSLVSH_469NS_234NS	(1 << 5)
+#define MAX96705_I2CSLVSH_352NS_117NS	(0 << 5)
+#define MAX96705_I2CMSTBT_837KBPS	(7 << 2)
+#define MAX96705_I2CMSTBT_533KBPS	(6 << 2)
+#define MAX96705_I2CMSTBT_339KBPS	(5 << 2)
+#define MAX96705_I2CMSTBT_173KBPS	(4 << 2)
+#define MAX96705_I2CMSTBT_105KBPS	(3 << 2)
+#define MAX96705_I2CMSTBT_84KBPS		(2 << 2)
+#define MAX96705_I2CMSTBT_28KBPS		(1 << 2)
+#define MAX96705_I2CMSTBT_8KBPS		(0 << 2)
+#define MAX96705_I2CSLVTO_NONE		(3 << 0)
+#define MAX96705_I2CSLVTO_1024US		(2 << 0)
+#define MAX96705_I2CSLVTO_256US		(1 << 0)
+#define MAX96705_I2CSLVTO_64US		(0 << 0)
+/* Register 0x0f */
+#define MAX96705_GPIO5OUT		BIT(5)
+#define MAX96705_GPIO4OUT		BIT(4)
+#define MAX96705_GPIO3OUT		BIT(3)
+#define MAX96705_GPIO2OUT		BIT(2)
+#define MAX96705_GPIO1OUT		BIT(1)
+#define MAX96705_GPO			BIT(0)
+/* Register 0x15 */
+#define MAX96705_PCLKDET			BIT(0)
+/* Register 0x1e */
+#define MAX96705_ID         0x41
+/* Register 0x43 */
+#define MAX96705_GEN_VS                 BIT(5)
+#define MAX96705_GEN_HS                 BIT(4)
+#define MAX96705_GEN_DE                 BIT(3)
+#define MAX96705_VS_TRIG_FALL           (0 << 2)
+#define MAX96705_VS_TRIG_RISE           (1 << 2)
+#define MAX96705_VTG_MODE_VS_TRACKED    (0 << 0)
+#define MAX96705_VTG_MODE_VS_FRAME      (1 << 0)
+#define MAX96705_VTG_MODE_VS_GEN        (2 << 0)
+
+/**
+ * struct max96705_device - max96705 device
+ * @client: The i2c client for the max96705 instance
+ */
+struct max96705_device {
+	struct i2c_client *client;
+};
+
+/**
+ * max96705_set_serial_link() - Enable/disable serial link
+ * @dev: The max96705 device
+ * @enable: Serial link enable/disable flag
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_serial_link(struct max96705_device *dev, bool enable);
+
+/**
+ * max96705_configure_i2c() - Configure I2C bus parameters
+ * @dev: The max96705 device
+ * @i2c_config: The I2C bus configuration bit mask
+ *
+ * Configure MAX96705 I2C interface. The bus configuration provided in the
+ * @i2c_config parameter shall be assembled using bit values defined by the
+ * MAX96705_I2C* macros.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_configure_i2c(struct max96705_device *dev, u8 i2c_config);
+
+/**
+ * max96705_set_high_threshold() - Enable or disable reverse channel high
+ *				  threshold
+ * @dev: The max96705 device
+ * @enable: High threshold enable/disable flag
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_high_threshold(struct max96705_device *dev, bool enable);
+
+/**
+ * max96705_configure_gmsl_link() - Configure the GMSL link
+ * @dev: The max96705 device
+ *
+ * FIXME: the GMSL link configuration is currently hardcoded and performed
+ * by programming registers 0x04, 0x07 and 0x02.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_configure_gmsl_link(struct max96705_device *dev);
+
+/**
+ * max96705_set_gpios() - Set gpio lines to physical high value
+ * @dev: The max96705 device
+ * @gpio_mask: The mask of gpio lines to set to high value
+ *
+ * The @gpio_mask parameter shall be assembled using the MAX96705_GP[IO|O]*
+ * bit values.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_gpios(struct max96705_device *dev, u8 gpio_mask);
+
+/**
+ * max96705_clear_gpios() - Set gpio lines to physical low value
+ * @dev: The max96705 device
+ * @gpio_mask: The mask of gpio lines to set to low value
+ *
+ * The @gpio_mask parameter shall be assembled using the MAX96705_GP[IO|O]*
+ * bit values.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_clear_gpios(struct max96705_device *dev, u8 gpio_mask);
+
+/**
+ * max96705_enable_gpios() - Enable gpio lines
+ * @dev: The max96705 device
+ * @gpio_mask: The mask of gpio lines to enable
+ *
+ * The @gpio_mask parameter shall be assembled using the MAX96705_GPIO*
+ * bit values. GPO line is always enabled by default.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_enable_gpios(struct max96705_device *dev, u8 gpio_mask);
+
+/**
+ * max96705_disable_gpios() - Disable gpio lines
+ * @dev: The max96705 device
+ * @gpio_mask: The mask of gpio lines to disable
+ *
+ * The @gpio_mask parameter shall be assembled using the MAX96705_GPIO*
+ * bit values. GPO line is always enabled by default and cannot be disabled.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_disable_gpios(struct max96705_device *dev, u8 gpio_mask);
+
+/**
+ * max96705_verify_id() - Read and verify MAX96705 id
+ * @dev: The max96705 device
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_verify_id(struct max96705_device *dev);
+
+/**
+ * max96705_set_address() - Program a new I2C address
+ * @dev: The max96705 device
+ * @addr: The new I2C address in 7-bit format
+ *
+ * This function only takes care of programming the new I2C address @addr to
+ * in the MAX96705 chip registers, it is responsiblity of the caller to set
+ * the i2c address client to the @addr value to be able to communicate with
+ * the MAX96705 chip using the I2C framework APIs after this function returns.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_address(struct max96705_device *dev, u8 addr);
+
+/**
+ * max96705_set_deserializer_address() - Program the remote deserializer address
+ * @dev: The max96705 device
+ * @addr: The deserializer I2C address in 7-bit format
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_deserializer_address(struct max96705_device *dev, u8 addr);
+
+/**
+ * max96705_set_translation() - Program I2C address translation
+ * @dev: The max96705 device
+ * @source: The I2C source address
+ * @dest: The I2C destination address
+ *
+ * Program address translation from @source to @dest. This is required to
+ * communicate with local devices that do not support address reprogramming.
+ *
+ * TODO: The device supports translation of two address, this function currently
+ * supports a single one.
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+int max96705_set_translation(struct max96705_device *dev, u8 source, u8 dest);
-- 
2.7.4

